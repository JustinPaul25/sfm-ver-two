import{o as T,c as w,e as y,g as Y,E as _,A as ha,h as Oe,m as W,j as Z,k as U,n as ae,p as ye,q as De,B as fa,r as ya,D as ga,u as ba,L as Na,v,w as re,S as wa,M as Ta,T as Ne,x as te,y as it,z as Sa,C as oe,R as va,F as Oa,G as _a,H as _e,I as pe,J as Ea,K as X,N as ne,O as ot,P as Aa,Q as Ot,U as _t,V as Et,W as ue,X as ut,Y as Ge,Z as Ke,_ as At,$ as ka,a0 as kt,a1 as It,a2 as $t,a3 as Dt,a4 as Ia,a5 as H,a6 as ge,a7 as Ct,a8 as zt,a9 as $a,aa as Da,ab as Ca,ac as za,ad as G,ae as La,af as Lt,ag as Fa,ah as xa,ai as Va,aj as Pa,ak as Ra,al as ja,am as lt,an as pt,ao as Ba,ap as Ha,aq as Wa,ar as qa,as as Ua,at as Ga,au as Ka,av as Ft,aw as mt,ax as Ja,ay as V,az as xt,aA as Qa,aB as Vt,aC as Xa,aD as Za,aE as Ya,aF as Ma,aG as Pt,aH as es,aI as ts,aJ as Rt,aK as as,aL as jt,aM as ss,aN as rs,aO as ns,aP as is,aQ as os,aR as us,aS as ls,aT as ps,aU as ms,aV as Ce,aW as se,aX as Bt,aY as cs,aZ as ds,a_ as hs,a$ as fs,b0 as ys,b1 as gs,b2 as bs,b3 as Ns,b4 as ws,b5 as Ts,b6 as Ss,b7 as vs,b8 as Os,b9 as _s,ba as Es,bb as As,bc as ks,bd as Is,be as $s,bf as Ds,bg as Cs,bh as zs,bi as Ls,bj as Fs,bk as xs,bl as Vs,bm as Ps,bn as Rs,bo as js,bp as Bs,bq as Hs,br as Je,bs as Qe,bt as Ws,bu as qs,bv as Us,bw as Gs,bx as Ks,by as Js,bz as Qs,bA as Xs,bB as Zs,bC as Ys,bD as Ht,bE as z,bF as Ms,bG as er,bH as tr,bI as ar,bJ as sr,bK as rr,bL as nr,bM as ir,bN as or,bO as ur,bP as lr,bQ as pr,bR as mr,bS as cr,bT as dr,bU as hr,bV as fr,bW as yr,bX as gr,bY as br,bZ as Nr,b_ as wr,b$ as Tr,c0 as Sr,c1 as vr,c2 as Or,c3 as _r,c4 as Er,c5 as Ar,c6 as kr,c7 as Ir,c8 as $r,c9 as Dr,ca as Cr,cb as zr,cc as Lr,cd as Fr,ce as xr,cf as Vr,cg as Pr,ch as Rr,ci as jr,cj as Br,ck as Hr,cl as Wr,cm as qr,cn as Ur,co as Gr,cp as Kr,cq as Jr,cr as Qr,cs as Xr,ct as Wt,cu as Zr,cv as Yr,cw as Mr,cx as en,cy as tn,cz as an,cA as sn,cB as rn,cC as nn,cD as on,i as qt,cE as un,cF as ln,cG as pn,cH as mn,cI as cn,cJ as dn,cK as hn,cL as fn,cM as yn,cN as gn,cO as bn,cP as Nn,cQ as wn,cR as Tn,cS as Sn,cT as vn,cU as On,cV as _n,cW as En,cX as An,cY as kn,cZ as In,c_ as $n,c$ as Dn,d0 as Cn,d1 as zn,d2 as Ln,d3 as Fn,d4 as xn,d5 as Vn,d6 as Pn,d7 as Rn,d8 as jn,d9 as Bn,da as Hn,db as Wn,dc as qn,dd as Un,de as Gn,df as Kn,dg as Jn,dh as Qn,di as Xn,dj as Zn,dk as Yn,dl as Mn,dm as ei,dn as ti,dp as ai,dq as si,dr as ri,ds as ni,dt as ii,du as oi,dv as ui,dw as li,dx as pi,dy as mi,dz as ci,dA as di,dB as hi,dC as fi,dD as yi,dE as gi,dF as ie,dG as bi,dH as Ni,dI as wi,dJ as Ti,dK as Si,dL as Ut,t as ze,dM as vi,dN as Oi,dO as _i,dP as Ei,dQ as Ai,dR as ki,dS as le,dT as Ii,dU as $i,dV as Di,dW as Ci,dX as B,dY as x,dZ as we,d_ as zi,d$ as Xe,e0 as Ee,f as Li,e1 as Gt,e2 as Fi,e3 as Kt,e4 as Jt,e5 as xi,e6 as Vi,e7 as Pi}from"./register_all_kernels-DbDytqLj.js";import{f4 as Am,f5 as km,f6 as Im,ei as $m,ej as Dm,ek as Cm,el as zm,f7 as Lm,f8 as Fm,f9 as xm,fa as Vm,fb as Pm,fc as Rm,fd as jm,fe as Bm,fg as Hm,ff as Wm,fh as qm,fj as Um,fk as Gm,fi as Km,fl as Jm,fm as Qm,fn as Xm,fo as Zm,hF as Ym,fp as Mm,fq as ec,fr as tc,fs as ac,ft as sc,fu as rc,fv as nc,fw as ic,fx as oc,fy as uc,fz as lc,fA as pc,fB as mc,fC as cc,fF as dc,fD as hc,fE as fc,hG as yc,eF as gc,fG as bc,fH as Nc,fI as wc,fJ as Tc,fK as Sc,fL as vc,fN as Oc,fM as _c,fO as Ec,eC as Ac,fQ as kc,fR as Ic,fS as $c,eB as Dc,fU as Cc,fT as zc,fV as Lc,fW as Fc,fX as xc,fY as Vc,fZ as Pc,f_ as Rc,f$ as jc,g0 as Bc,hA as Hc,g1 as Wc,hD as qc,hY as Uc,g2 as Gc,g3 as Kc,g4 as Jc,hH as Qc,g6 as Xc,g5 as Zc,g7 as Yc,hI as Mc,g8 as ed,g9 as td,ga as ad,eE as sd,gm as rd,gn as nd,hP as id,gb as od,gc as ud,gd as ld,ge as pd,gf as md,gk as cd,gg as dd,gh as hd,gi as fd,gj as yd,gl as gd,hR as bd,hW as Nd,go as wd,gp as Td,gr as Sd,gt as vd,gu as Od,gs as _d,gq as Ed,gv as Ad,gw as kd,gx as Id,gy as $d,gz as Dd,em as Cd,gA as zd,gB as Ld,gD as Fd,gE as xd,gF as Vd,gC as Pd,gH as Rd,gG as jd,en as Bd,eo as Hd,gI as Wd,gJ as qd,gK as Ud,gL as Gd,gM as Kd,gN as Jd,ep as Qd,hN as Xd,gO as Zd,es as Yd,gP as Md,fP as eh,gQ as th,ev as ah,gR as sh,gX as rh,gS as nh,gV as ih,gW as oh,gT as uh,gU as lh,gY as ph,hB as mh,gZ as ch,g_ as dh,eq as hh,g$ as fh,h0 as yh,hO as gh,h5 as bh,h4 as Nh,h2 as wh,h3 as Th,h1 as Sh,hb as vh,h6 as Oh,h9 as _h,hc as Eh,hd as Ah,he as kh,hf as Ih,ha as $h,h7 as Dh,hh as Ch,hg as zh,hi as Lh,hz as Fh,hj as xh,hk as Vh,hl as Ph,hm as Rh,hn as jh,h8 as Bh,hJ as Hh,ho as Wh,hp as qh,hq as Uh,hr as Gh,hs as Kh,ht as Jh,hu as Qh,hv as Xh,hw as Zh,hx as Yh,er as Mh,hy as ef,hC as tf,eW as af,eb as sf,ec as rf,e8 as nf,f3 as of,eJ as uf,eh as lf,eI as pf,eK as mf,eH as cf,eG as df,eL as hf,eT as ff,eU as yf,hV as gf,ef as bf,eR as Nf,eZ as wf,eY as Tf,e_ as Sf,hT as vf,ew as Of,ex as _f,hK as Ef,hE as Af,l as kf,eM as If,hL as $f,eD as Df,eN as Cf,eQ as zf,eV as Lf,hM as Ff,f0 as xf,e$ as Vf,eS as Pf,eg as Rf,s as jf,e9 as Bf,eP as Hf,eX as Wf,hX as qf,hQ as Uf,ee as Gf,et as Kf,ed as Jf,eO as Qf,b as Xf,f2 as Zf,f1 as Yf,eu as Mf,ea as ey,ey as ty,ez as ay,eA as sy,hS as ry,hU as ny}from"./register_all_kernels-DbDytqLj.js";import"./app-cXB0WXeG.js";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ri(a){w(Array.isArray(a),()=>"The argument passed to tf.addN() must be a list of tensors"),w(a.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${a.length}`);const e=a.map((r,n)=>y(r,`tensors${n}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Y(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return _.runKernel(ha,s)}const ji=T({addN_:Ri});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bi(a,e,t,s,r,n){const u=y(a,"forgetBias","basicLSTMCell"),o=y(e,"lstmKernel","basicLSTMCell"),l=y(t,"lstmBias","basicLSTMCell"),p=y(s,"data","basicLSTMCell"),m=y(r,"c","basicLSTMCell"),c=y(n,"h","basicLSTMCell"),d=Oe([p,c],1),h=W(d,o),N=Z(h,l),g=N.shape[0],f=N.shape[1]/4,b=[g,f],O=U(N,[0,0],b),I=U(N,[0,f],b),S=U(N,[0,f*2],b),k=U(N,[0,f*3],b),D=Z(ae(ye(O),De(I)),ae(m,ye(Z(u,S)))),C=ae(De(D),ye(k));return[D,C]}const Hi=T({basicLSTMCell_:Bi});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wi(a,e){const t=y(a,"x","bitwiseAnd"),s=y(e,"y","bitwiseAnd");if(!Y(t.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${s.shape}`);if(t.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${s.dtype}`);const r={a:t,b:s};return _.runKernel(fa,r)}const qi=T({bitwiseAnd_:Wi});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ui(a,e){const t=y(a,"s0","broadcastArgs","int32"),s=y(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return _.runKernel(ya,r)}const Gi=T({broadcastArgs_:Ui});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ki(a){const t={x:y(a,"x","diag")};return _.runKernel(ga,t)}const Ji=T({diag_:Ki});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qi(a,e){const t=y(a,"x","ensureShape","string_or_numeric");if(!ba(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return a}const Xi=T({ensureShape_:Qi});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zi(a,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:a,stop:e,num:t};return _.runKernel(Na,{},s)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const me=2147483648;function Yi(a,e,t="left"){const s=y(a,"sortedSequence","searchSorted"),r=y(e,"values","searchSorted"),n=s.shape[s.shape.length-1],u=r.shape[r.shape.length-1],o=v(s,[-1,n]),l=v(r,[-1,u]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(re(l.shape)>=me)throw new Error(`values tensor size must less than ${me}`);if(o.shape[1]>=me)throw new Error(`trailing dim_size must less than ${me} for int32 output type, was ${o.shape[1]}`);const p={sortedSequence:o,values:l},m={side:t};return _.runKernel(wa,p,m)}const Ze=T({searchSorted_:Yi});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mi(a,e){return Ze(a,e,"left")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(a,e,t,s,r=!1){const u={x:y(a,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=_.runKernel(Ta,u,o);return{result:l[0],indexes:l[1]}}const to=T({maxPoolWithArgmax_:eo});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(a,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(a===void 0)return[];let s=y(a,"x","meshgrid",a instanceof Ne?a.dtype:"float32");if(e===void 0)return[s];let r=y(e,"y","meshgrid",e instanceof Ne?e.dtype:"float32");const n=re(s.shape),u=re(r.shape);return t==="xy"?(s=v(s,[1,-1]),r=v(r,[-1,1]),[W(te([u,1],s.dtype),s),W(r,te([1,n],r.dtype))]):(s=v(s,[-1,1]),r=v(r,[1,-1]),[W(s,te([1,u],s.dtype)),W(te([n,1],r.dtype),r)])}function so(a,e,t,s){const r=y(e,"data","multiRNNCell"),n=it(t,"c","multiRNNCell"),u=it(s,"h","multiRNNCell");let o=r;const l=[];for(let c=0;c<a.length;c++){const d=a[c](o,n[c],u[c]);l.push(d[0]),l.push(d[1]),o=d[1]}const p=[],m=[];for(let c=0;c<l.length;c+=2)p.push(l[c]),m.push(l[c+1]);return[p,m]}const ro=T({multiRNNCell_:so});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(a,e,t,s=!1){const r=y(a,"logits","multinomial"),n=r.size,u=r.rank;if(n<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${n}.`);if(u>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${u}`);t=t||Math.random();const l={logits:u===1?v(r,[1,-1]):r},p={numSamples:e,seed:t,normalized:s},m=_.runKernel(Sa,l,p);return u===1?v(m,[m.size]):m}const io=T({multinomial_:no});function oo(a,e){const t=y(a,"v1","outerProduct"),s=y(e,"v2","outerProduct");w(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=v(t,[-1,1]),n=v(s,[1,-1]);return W(r,n)}const uo=T({outerProduct_:oo});function lo(a,e,t=0){return w(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),oe(a,[e],t)}const po=T({pad1d_:lo});function mo(a,e,t=0){return w(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),oe(a,e,t)}const co=T({pad2d_:mo});function ho(a,e,t=0){return w(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),oe(a,e,t)}const fo=T({pad3d_:ho});function yo(a,e,t=0){return w(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),oe(a,e,t)}const go=T({pad4d_:yo});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bo(a,e,t,s){const r=a.map((m,c)=>y(m,`tensors${c}`,"raggedGather","int32")),n=y(e,"paramsDenseValues","raggedGather"),u=y(t,"indices","raggedGather","int32"),o={paramsNestedSplits:r,paramsDenseValues:n,indices:u},l={outputRaggedRank:s},p=_.runKernel(va,o,l);return{outputNestedSplits:p.slice(0,p.length-1),outputDenseValues:p[p.length-1]}}const No=T({raggedGather_:bo});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wo(a,e,t){const s=y(a,"starts","raggedRange"),r=y(e,"limits","raggedRange",s.dtype),n=y(t,"deltas","raggedRange",s.dtype),u={starts:s,limits:r,deltas:n},o=_.runKernel(Oa,u);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const To=T({raggedRange_:wo});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function So(a,e,t,s,r){const n=y(a,"shape","raggedTensorToTensor","int32"),u=y(e,"values","raggedTensorToTensor"),o=y(t,"defaultValue","raggedTensorToTensor",u.dtype),l=s.map((c,d)=>y(c,`tensors${d}`,"raggedTensorToTensor","int32")),p={shape:n,values:u,defaultValue:o,rowPartitionTensors:l},m={rowPartitionTypes:r};return _.runKernel(_a,p,m)}const vo=T({raggedTensorToTensor_:So});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oo(a,e,t){_e(a);const s=re(a);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let n=0;n<s;n++)r[n]=e();return _.makeTensor(r,a,t)}const _o=T({rand_:Oo});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eo=.001,Qt=.1;function Ao(a,e,t){return t==null&&(t=Ye()),Le(a,e,(s,r)=>Me(s,r,t))}function Ye(){return _.backend.floatPrecision()===32?Eo:Qt}function Le(a,e,t){let s=!0;if((X(a)||X(e))&&(s=!1),X(a)&&X(e)&&(s=!0),s){const u=a.constructor.name,o=e.constructor.name;if(u!==o)throw new Error(`Arrays are of different type. Actual: ${u}. Expected: ${o}`)}if(Array.isArray(a)&&Array.isArray(e)){const u=ne(a),o=ne(e);if(!Y(u,o))throw new Error(`Arrays have different shapes. Actual: [${u}]. Expected: [${o}]`)}const r=X(a)?a:ot(a),n=X(e)?e:ot(e);if(r.length!==n.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${n.length}.
Actual:   ${r}.
Expected: ${n}.`);for(let u=0;u<n.length;++u){const o=r[u],l=n[u];if(!t(o,l))throw new Error(`Arrays differ: actual[${u}] = ${o}, expected[${u}] = ${l}.
Actual:   ${r}.
Expected: ${n}.`)}typeof expect<"u"&&expect().nothing()}function ko(a,e){a().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function Io(a,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return pe(a)||pe(a[0])||pe(e)||pe(e[0])?Le(a,t,(s,r)=>s==r):Le(a,e,(s,r)=>Me(s,r,0))}function $o(a,e,t){if(t==null&&(t=Ye()),!Me(a,e,t))throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function Me(a,e,t){return!isFinite(a)&&!isFinite(e)?!0:!(isNaN(a)||isNaN(e)||Math.abs(a-e)>t)}function Do(a,e,t){for(let s=0;s<a.length;s++)if(a[s]<e||a[s]>t)throw new Error(`Value out of range:${a[s]} low: ${e}, high: ${t}`)}function Co(a,e){const t=new Float32Array(a),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let r=0;r<s.length;r++)if(t[r]!==s[r])throw new Error(`Expected ArrayBuffer value at ${r} to be ${s[r]} but got ${t[r]} instead`)}function Xt(a){for(let e=0;e<a.length;e++){const t=a[e];Array.isArray(t)?Xt(t):a[e]=Ea(t)}return a}function zo(a){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(a),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function Lo(a){await a.play(),"requestVideoFrameCallback"in a&&await new Promise(e=>{a.requestVideoFrameCallback(e)})}const pm=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:Qt,createVideoElement:zo,encodeStrings:Xt,expectArrayBuffersEqual:Co,expectArraysClose:Ao,expectArraysEqual:Io,expectNumbersClose:$o,expectPromiseToFail:ko,expectValuesInRange:Do,play:Lo,testEpsilon:Ye},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fo(a,e,t=1,s="float32",r){if(_e(a),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const n=new Aa(e,t,s,r),u=Ot(a,s);for(let o=0;o<u.values.length;o++)u.values[o]=n.nextValue();return u.toTensor()}const xo=T({randomGamma_:Fo});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vo(a,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return _t(a,0,1,e,t)}const Po=T({randomStandardNormal_:Vo});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ro(a,e,t,s){return Et(a,e,t,"int32",s)}const jo=T({randomUniformInt_:Ro});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(a){const e=y(a,"x","reverse");return w(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),ue(e,0)}const Ho=T({reverse1d_:Bo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wo(a,e){const t=y(a,"x","reverse");return w(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),ue(t,e)}const qo=T({reverse2d_:Wo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uo(a,e){const t=y(a,"x","reverse");return w(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),ue(t,e)}const Go=T({reverse3d_:Uo});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ko(a,e){const t=y(a,"x","reverse");return w(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),ue(t,e)}const Jo=T({reverse4d_:Ko});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Qo(a,e){const t=y(a,"x","setdiff1d"),s=y(e,"y","setdiff1d");w(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),w(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),w(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),n=await s.data(),u=new Set(n);let o=0;for(let m=0;m<r.length;m++)u.has(r[m])||o++;const l=new ut([o],t.dtype),p=new ut([o],"int32");for(let m=0,c=0;m<r.length;m++)u.has(r[m])||(l.values[c]=r[m],p.values[c]=m,c++);return[l.toTensor(),p.toTensor()]}const Xo=Qo;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zo(a,e,t){if(Ge(a),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=ne(a,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ke(a,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(a,e,t){if(Ge(a),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=ne(a,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ke(a,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mo(a,e,t){if(Ge(a),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=ne(a,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Ke(a,e,s,t)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eu(a,e,t){const s=y(a,"tensor","tensorScatterupdate"),r=y(e,"indices","tensorScatterupdate","int32"),n=y(t,"updates","tensorScatterupdate");if(At(n,r,s.shape),s.dtype!==n.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${n.dtype}.`);const u={tensor:s,indices:r,updates:n},o={};return _.runKernel(ka,u,o)}const tu=T({tensorScatterUpdate_:eu});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function au(a,e){return Ze(a,e,"right")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function su(a){const e=y(a,"condition","whereAsync","bool"),t=await e.data(),s=kt(e.shape,t);return a!==e&&e.dispose(),s}const Zt=su;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ru(a,e,t){const s=y(a,"tensor","boolMask"),r=y(e,"mask","boolMask","bool"),n=t??0,u=r.rank,o=s.shape;w(u>0,()=>"mask cannot be scalar"),It(o.slice(n,n+u),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let g=n;g<n+u;g++)l*=o[g];const p=o.slice(0,n).concat([l],o.slice(n+u)),m=v(s,p),c=v(r,[-1]),d=await Zt(c),h=$t(d,[1]),N=Dt(m,h,n);return a!==s&&s.dispose(),e!==r&&r.dispose(),h.dispose(),m.dispose(),c.dispose(),d.dispose(),N}const nu=ru;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iu(a,e,t,s,r=!0){const n=y(a,"v","movingAverage"),u=y(e,"x","movingAverage"),o=y(t,"decay","movingAverage");Ia(n,u),w(Y(n.shape,u.shape),()=>"Shape mismatch in v and x");const l=H(1),p=ge(l,o);let m=ae(ge(u,n),p);if(r){w(s!=null,()=>"When using zeroDebias: true, step is required.");const c=y(s,"step","movingAverage");m=Ct(m,ge(l,zt(o,c)))}return Z(n,m)}const ou=T({movingAverage_:iu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uu(a,e,t){_e(t);const s=y(a,"indices","scatterND","int32"),r=y(e,"updates","scatterND");At(r,s,t);const n={indices:s,updates:r},u={shape:t};return _.runKernel($a,n,u)}const lu=T({scatterND_:uu});function pu(a,e,t,s){if(a.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${a.dtype}.`);if(a.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${a.shape}.`);const r=a.rank>0?a.shape[0]:1,n=a.rank>1?a.shape[1]:1;if(t.length!==n)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${n}.`);const u=e.size;if(!(e.rank===0||e.rank===1&&u===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(a,e,t,s=0){_e(t);const r=y(a,"sparseIndices","sparseToDense","int32"),n=y(e,"sparseValues","sparseToDense","string_or_numeric"),u=y(s,"defaultValue","sparseToDense",n.dtype);pu(r,n,t,u);const o={sparseIndices:r,sparseValues:n,defaultValue:u},l={outputShape:t};return _.runKernel(Da,o,l)}const cu=T({sparseToDense_:mu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function du(a,e){const t=y(e,"indices","gatherND","int32"),r={params:y(a,"x","gatherND","string_or_numeric"),indices:t};return _.runKernel(Ca,r)}const hu=T({gatherND_:du});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function fu(a,e,t=1){const s=y(a,"predictions","inTopK"),r=y(e,"targets","inTopK");w(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),w(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),It(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const n=s.shape[s.shape.length-1];w(t>0&&t<=n,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${n}), but got ${t}`);const u=await s.data(),o=await r.data(),[l,p]=[u.length/n,n],m=za("bool",l);for(let c=0;c<l;c++){const d=c*p,h=u.subarray(d,d+p),N=[];for(let g=0;g<h.length;g++)N.push({value:h[g],index:g});N.sort((g,f)=>f.value-g.value),m[c]=0;for(let g=0;g<t;g++)if(N[g].index===o[c]){m[c]=1;break}}return a!==s&&s.dispose(),e!==r&&r.dispose(),G(m,r.shape,"bool")}const yu=fu;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gu({x:a,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:n=[1,1],dimRoundingMode:u,bias:o,activation:l="linear",preluActivationWeights:p,leakyreluAlpha:m}){if(La(_.state.gradientDepth,l)===!1){let k=Lt(a,e,t,s,r,n,u);return o!=null&&(k=Z(k,o)),Fa(k,l,p,m)}const c=y(a,"x","depthwiseConv2d","float32"),d=y(e,"filter","depthwiseConv2d","float32");let h=c,N=!1;c.rank===3&&(N=!0,h=v(c,[1,c.shape[0],c.shape[1],c.shape[2]])),w(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),w(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),w(h.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),n==null&&(n=[1,1]),w(xa(t,n),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${n}'`),Va("fused depthwiseConv2d",s,u);const g=Pa(h.shape,d.shape,t,n,s,u,!0);let f;o!=null&&(f=y(o,"bias","fused conv2d"),[f]=Ra(f,c),ja(g.outShape,f.shape));let b;p!=null&&(b=y(p,"prelu weights","fused depthwiseConv2d"));const O=(k,D)=>{w(Ba(n),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${n}'`);const[C,Q,F,P]=D,Ae=Ha(k,F,l),rt=Wa(Q.shape,Ae,C,t,s,n,u),nt=qa(Q,Ae,C.shape,t,s,n,u);if(P!=null){const da=Ua(f,Ae);return[rt,nt,da]}return[rt,nt]},I={x:h,filter:d,bias:f,preluActivationWeights:b},S={strides:t,pad:s,dataFormat:r,dilations:n,dimRoundingMode:u,activation:l,leakyreluAlpha:m};return o==null?lt((D,C,Q)=>{let F=_.runKernel(pt,I,S);return Q([C,D,F]),N&&(F=v(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:O}})(h,d):lt((D,C,Q,F)=>{let P=_.runKernel(pt,I,S);return F([C,D,P,Q]),N&&(P=v(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:O}})(h,d,f)}const bu=T({fusedDepthwiseConv2d_:gu});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nu=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Ga,depthwiseConv2d:bu,matMul:Ka},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wu="model",Tu=".json",Su=".weights.bin";function ct(a){return new Promise(e=>setTimeout(e)).then(a)}class K{constructor(e){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(K.URL_SCHEME)&&(e=e.slice(K.URL_SCHEME.length)),(e==null||e.length===0)&&(e=wu),this.modelJsonFileName=e+Tu,this.weightDataFileName=e+Su}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=xt.join(e.weightData),s=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],n=Qa(e,r),u=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=u,await ct(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=s,await ct(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Vt(e)}}}}K.URL_SCHEME="downloads://";class vu{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const n=JSON.parse(r.target.result),u=n.modelTopology;if(u==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(n.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:u});return}const l=Ft(n,p=>this.loadWeights(p));e(l)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const u of e)t.push(...u.weights),s.push(...u.paths);const r=this.checkManifestAndWeightFiles(e),n=s.map(u=>this.loadWeightsFile(u,r[u]));return Promise.all(n).then(u=>[t,u])}loadWeightsFile(e,t){return new Promise((s,r)=>{const n=new FileReader;n.onload=u=>{const o=u.target.result;s(o)},n.onerror=u=>r(`Failed to weights data from file of path '${e}'.`),n.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(n=>mt(n.name)),r={};for(const n of e)n.paths.forEach(u=>{const o=mt(u);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);r[u]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const Ou=a=>V().getBool("IS_BROWSER")&&!Array.isArray(a)&&a.startsWith(K.URL_SCHEME)?_u(a.slice(K.URL_SCHEME.length)):null;Ja.registerSaveRouter(Ou);function _u(a="model"){return new K(a)}function Eu(a){return new vu(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ke{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Yt{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Au{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function ku(a,e,t,s){const r=arguments;return new Au(Te(...r))}function Te(a,e,t,s){return arguments.length===1?a.modelTopology!=null||a.weightSpecs!=null?new ke(a):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ke({modelTopology:a})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ke({modelTopology:a,weightSpecs:e,weightData:t,trainingConfig:s}))}function Iu(a){return new Yt(a)}function $u(a){return new Yt(a)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mt=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:xt,browserFiles:Eu,browserHTTPRequest:Xa,concatenateArrayBuffers:Za,copyModel:Ya,decodeWeights:Ma,decodeWeightsStream:Pt,encodeWeights:es,fromMemory:ku,fromMemorySync:Te,getLoadHandlers:ts,getModelArtifactsForJSON:Ft,getModelArtifactsForJSONSync:Rt,getModelArtifactsInfoForJSON:Vt,getSaveHandlers:as,getWeightSpecs:jt,http:ss,isHTTPScheme:rs,listModels:ns,loadWeights:is,moveModel:os,registerLoadRouter:us,registerSaveRouter:ls,removeModel:ps,weightsLoaderFactory:ms,withSaveHandler:Iu,withSaveHandlerSync:$u},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Du(a,e,t){const s=y(a,"labels","confusionMatrix"),r=y(e,"predictions","confusionMatrix");w(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),w(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),w(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),w(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),w(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const n=Ce(se(s,"int32"),t),u=Ce(se(r,"int32"),t),o=Bt(n),l=W(o,u);return se(l,"int32")}const Cu=T({confusionMatrix_:Du});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mm=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Cu},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const zu="4.22.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cm=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:cs,nonMaxSuppressionV4Impl:ds,nonMaxSuppressionV5Impl:hs,whereImpl:kt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lu(a){return new fs(a)}function Fu(a){return new ys(a)}function xu(){return new gs}function Vu(a){return new bs(a)}const dm=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Lu,minMaxNorm:Vu,nonNeg:xu,unitNorm:Fu},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Pu(){return new Ns}function Ru(){return new ws}function ju(a){return new Ts(a)}function Bu(a){return new Ss(a)}function Hu(a){return new vs(a)}function Wu(a){return new Os(a)}function qu(a){return new _s(a)}function Uu(a){return new Es(a)}function Gu(a){return new As(a)}function Ku(a){return new ks(a)}function Ju(a){return new Is(a)}function Qu(a){return new $s(a)}function Xu(a){return new Ds(a)}function Zu(a){return new Cs(a)}function Yu(a){return new zs(a)}const hm=Object.freeze(Object.defineProperty({__proto__:null,constant:ju,glorotNormal:Ku,glorotUniform:Gu,heNormal:Ju,heUniform:Qu,identity:qu,leCunNormal:Xu,leCunUniform:Zu,ones:Ru,orthogonal:Yu,randomNormal:Hu,randomUniform:Bu,truncatedNormal:Wu,varianceScaling:Uu,zeros:Pu},Symbol.toStringTag,{value:"Module"}));function Mu(a,e){return Ls(a,e)}function el(a,e){return Fs(a,e)}function tl(a,e){return xs(a,e)}function al(a,e){return Vs(a,e)}function sl(a,e){return Ps(a,e)}function rl(a,e){return Rs(a,e)}function nl(a,e){return js(a,e)}function il(a,e){return Bs(a,e)}function ol(a,e){return Hs(a,e)}function ul(a,e){return Je(a,e)}function ll(a,e){return Je(a,e)}function pl(a,e){return Je(a,e)}function ml(a,e){return Qe(a,e)}function cl(a,e){return Qe(a,e)}function dl(a,e){return Qe(a,e)}function hl(a,e){return Ws(a,e)}const fm=Object.freeze(Object.defineProperty({__proto__:null,MAPE:ll,MSE:cl,binaryAccuracy:Mu,binaryCrossentropy:el,categoricalAccuracy:al,categoricalCrossentropy:sl,cosineProximity:il,mape:pl,meanAbsoluteError:ol,meanAbsolutePercentageError:ul,meanSquaredError:ml,mse:dl,precision:rl,r2Score:hl,recall:nl,sparseCategoricalAccuracy:tl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ym=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:qs},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fl(a){return new Us(a)}function yl(a){return Gs(a)}function gl(a){return Ks(a)}const gm=Object.freeze(Object.defineProperty({__proto__:null,l1:yl,l1l2:fl,l2:gl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class bl extends Js{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Qs))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function ce(a,e){return a<e}function dt(a,e){return a>e}class Nl extends bl{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Xs("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=ce:this.mode==="max"?this.monitorFunc=dt:this.monitor.indexOf("acc")!==-1?this.monitorFunc=dt:this.monitorFunc=ce,this.monitorFunc===ce&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===ce?1/0:-1/0}async onEpochEnd(e,t){await Zs(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function wl(a){return new Nl(a)}const bm={earlyStopping:wl};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const et={};function Nm(a,e){const t={tfOpName:a,category:"custom",inputs:[],attrs:[],customExecutor:e};et[a]=t}function ea(a){return et[a]}function wm(a){delete et[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i(a,e,t,s,r){const n=e.inputParams[a];if(n&&n.inputIndexStart!==void 0){const o=n.inputIndexStart,l=n.inputIndexEnd===0?void 0:n.inputIndexEnd===void 0?o+1:n.inputIndexEnd,p=o<0?e.inputNames.length+o:o;if(n.type==="tensor")return E(e.inputNames[p],t,s,r);if(n.type==="tensors"){const d=e.inputs.slice(o,l);return e.inputNames.slice(o,l).filter((N,g)=>{var f;return((f=d[g])===null||f===void 0?void 0:f.op)!=="NoOp"}).map(N=>E(N,t,s,r))}const m=E(e.inputNames[p],t,s,r),c=m.dataSync();return n.type==="number"?c[0]:Ys(m.shape,c)}const u=e.attrParams[a];return u&&u.value}function E(a,e,t,s){const[r,n]=$(a,t);if(s!=null){const o=s.getHashTableHandleByName(r);if(o!=null)return o}const u=t.currentContextIds.find(o=>!!e[Se(r,o)]);return u!==void 0?e[Se(r,u)][n]:void 0}function ht(a,e,t){return e[Se(a,t.currentContextId)]}function R(a,e){const[t,s,r]=$(a,e);return[Se(t,e&&e.currentContextId),s,r]}function Se(a,e){return e?`${a}-${e}`:a}function $(a,e){if(a==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const n=e.parseNodeNameCache.get(a);if(n!=null)return n}const s=a.split(":");let r;if(s.length===1)r=[a,0,void 0];else{const n=s[0],u=s.length===3?s[1]:void 0,o=Number(s[s.length-1]);r=[n,o,u]}return t&&e.parseNodeNameCache.set(a,r),r}function be(a,e,t){let s=i("pad",a,e,t);if(s==="explicit"){s=i("explicitPaddings",a,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let n=0;n<4;n++)r[n][0]=s[n*2],r[n][1]=s[n*2+1];return r}return s}function j(a){return a.kept?a:Ht(a)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tl=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Sl=Object.freeze(Object.defineProperty({__proto__:null,json:Tl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vl=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ol=Object.freeze(Object.defineProperty({__proto__:null,json:vl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _l=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],El=Object.freeze(Object.defineProperty({__proto__:null,json:_l},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Al=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],kl=Object.freeze(Object.defineProperty({__proto__:null,json:Al},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Il=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],$l=Object.freeze(Object.defineProperty({__proto__:null,json:Il},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dl=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Cl=Object.freeze(Object.defineProperty({__proto__:null,json:Dl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Ll=Object.freeze(Object.defineProperty({__proto__:null,json:zl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fl=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],xl=Object.freeze(Object.defineProperty({__proto__:null,json:Fl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vl=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Pl=Object.freeze(Object.defineProperty({__proto__:null,json:Vl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rl=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],jl=Object.freeze(Object.defineProperty({__proto__:null,json:Rl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Hl=Object.freeze(Object.defineProperty({__proto__:null,json:Bl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wl=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],ql=Object.freeze(Object.defineProperty({__proto__:null,json:Wl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ul=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Gl=Object.freeze(Object.defineProperty({__proto__:null,json:Ul},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kl=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Jl=Object.freeze(Object.defineProperty({__proto__:null,json:Kl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ql=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Xl=Object.freeze(Object.defineProperty({__proto__:null,json:Ql},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zl=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Yl=Object.freeze(Object.defineProperty({__proto__:null,json:Zl},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ml=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],ep=Object.freeze(Object.defineProperty({__proto__:null,json:Ml},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tp=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],ap=Object.freeze(Object.defineProperty({__proto__:null,json:tp},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sp=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],rp=Object.freeze(Object.defineProperty({__proto__:null,json:sp},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ft{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Sl,Ol,El,kl,$l,Cl,Ll,xl,Pl,jl,Hl,ql,Gl,Jl,Xl,Yl,ep,ap,rp],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],n=[],u=[],o=s.reduce((g,f)=>(g[f.name]=this.mapNode(f),f.op.startsWith("Placeholder")?r.push(g[f.name]):f.op==="Const"?n.push(g[f.name]):(f.input==null||f.input.length===0)&&u.push(g[f.name]),g),{});let l=[];const p=[];let m={},c={};t!=null&&(m=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach(g=>{const f=o[g];f.inputNames.forEach((b,O)=>{const[I,,S]=R(b),k=o[I];if(k.outputs!=null){const D=k.outputs.indexOf(S);if(D!==-1){const C=`${I}:${D}`;f.inputNames[O]=C}}f.inputs.push(k),k.children.push(f)})}),Object.keys(c).length===0?d.forEach(g=>{const f=o[g];f.children.length===0&&p.push(f)}):Object.keys(c).forEach(g=>{const[f]=R(g),b=o[f];b!=null&&(b.signatureKey=c[g],p.push(b))}),Object.keys(m).length>0?Object.keys(m).forEach(g=>{const[f]=R(g),b=o[f];b&&(b.signatureKey=m[g],l.push(b))}):l=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((g,f)=>(g[f.signature.name]=this.mapFunction(f),g),{}));const N={nodes:o,inputs:l,outputs:p,weights:n,placeholders:r,signature:t,functions:h};return u.length>0&&(N.initNodes=u),N}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=ea(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,n)=>(r[n.name]={type:n.type,inputIndexStart:n.start,inputIndexEnd:n.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,n)=>{const u=n.type;let o;switch(n.type){case"string":o=Fe(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=Fe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":o=He(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=He(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":o=Ve(e.attr,n.tfName,n.defaultValue||0),o===void 0&&n.tfDeprecatedName&&(o=Ve(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":o=Be(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=Be(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":o=xe(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=xe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":o=qe(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=qe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":o=je(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=je(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":o=We(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=We(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":o=Pe(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=Pe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":o=Re(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=Re(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":o=yt(e.attr,n.tfName,n.defaultValue),o===void 0&&n.tfDeprecatedName&&(o=yt(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return r[n.name]={value:o,type:u},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let n={};t!=null&&(n=t.reduce((c,d)=>(c[d.name]=this.mapNode(d),d.op==="Const"&&r.push(c[d.name]),c),{}));const u=[],o=[];e.signature.inputArg.forEach(c=>{const[d]=R(c.name),h={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:tt(c.type),type:"dtype"}},children:[]};h.signatureKey=c.name,u.push(h),n[d]=h}),Object.keys(n).forEach(c=>{const d=n[c];d.inputNames.forEach((h,N)=>{const[g,,f]=R(h),b=n[g];if(b.outputs!=null){const O=b.outputs.indexOf(f);if(O!==-1){const I=`${g}:${O}`;d.inputNames[N]=I}}d.inputs.push(b),b.children.push(d)})});const p=e.ret;e.signature.outputArg.forEach(c=>{const[d,h]=R(p[c.name]),N=n[d];N!=null&&(N.defaultOutput=h,o.push(N))});const m=this.mapArgsToSignature(e);return{nodes:n,inputs:u,outputs:o,weights:r,placeholders:s,signature:m}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function np(a){const e=V().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function ta(a,e){const t=Array.isArray(a)?String.fromCharCode.apply(null,a):np(a);return e?t:t.toLowerCase()}function Fe(a,e,t,s=!1){const r=a[e];return r!=null?ta(r.s,s):t}function xe(a,e,t){const s=a[e];return s?s.b:t}function Ve(a,e,t){const s=a[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function tt(a){switch(typeof a=="string"&&(a=z[a]),a){case z.DT_FLOAT:case z.DT_HALF:return"float32";case z.DT_INT32:case z.DT_INT64:case z.DT_INT8:case z.DT_UINT8:return"int32";case z.DT_BOOL:return"bool";case z.DT_DOUBLE:return"float32";case z.DT_STRING:return"string";case z.DT_COMPLEX64:case z.DT_COMPLEX128:return"complex64";default:return null}}function yt(a,e,t){const s=a[e];return s&&s.func?s.func.name:t}function Pe(a,e,t){const s=a[e];return s&&s.type?tt(s.type):t}function Re(a,e,t){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(r=>tt(r)):t}function aa(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function je(a,e,t){const s=a[e];return s&&s.shape?aa(s.shape):t}function Be(a,e,t){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function He(a,e,t,s=!1){const r=a[e];return r&&r.list&&r.list.s?r.list.s.map(n=>ta(n,s)):t}function We(a,e,t){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>aa(r)):t}function qe(a,e,t){const s=a[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ip{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,n)=>(r[n]=this.getAttr(n),r),{}))}getInput(e){return E(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return E(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Ve(this.node.rawAttrs,e,t);if(s.s!=null)return Fe(this.node.rawAttrs,e,t);if(s.b!=null)return xe(this.node.rawAttrs,e,t);if(s.shape!=null)return je(this.node.rawAttrs,e,t);if(s.type!=null)return Pe(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Be(this.node.rawAttrs,e,t);if(s.list.s!=null)return He(this.node.rawAttrs,e,t);if(s.list.shape!=null)return We(this.node.rawAttrs,e,t);if(s.list.b!=null)return qe(this.node.rawAttrs,e,t);if(s.list.type!=null)return Re(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Ms,abs:er,acos:tr,acosh:ar,add:Z,addN:ji,all:sr,any:rr,argMax:nr,argMin:ir,asin:or,asinh:ur,atan:lr,atan2:pr,atanh:mr,avgPool:cr,avgPool3d:dr,basicLSTMCell:Hi,batchNorm:hr,batchNorm2d:fr,batchNorm3d:yr,batchNorm4d:gr,batchToSpaceND:br,bincount:Nr,bitwiseAnd:qi,booleanMaskAsync:nu,broadcastArgs:Gi,broadcastTo:wr,buffer:Ot,cast:se,ceil:Tr,clipByValue:Sr,clone:Ht,complex:vr,concat:Oe,concat1d:Or,concat2d:_r,concat3d:Er,concat4d:Ar,conv1d:kr,conv2d:Ir,conv2dTranspose:$r,conv3d:Dr,conv3dTranspose:Cr,cos:zr,cosh:Lr,cosineWindow:Fr,cumprod:xr,cumsum:Vr,denseBincount:Pr,depthToSpace:Rr,depthwiseConv2d:Lt,diag:Ji,dilation2d:jr,div:Ct,divNoNan:Br,dot:Hr,dropout:Wr,einsum:qr,elu:Ur,enclosingPowerOfTwo:Gr,ensureShape:Xi,equal:Kr,erf:Jr,euclideanNorm:Qr,exp:Xr,expandDims:Wt,expm1:Zr,eye:Yr,fft:Mr,fill:en,floor:tn,floorDiv:an,fused:Nu,gather:Dt,gatherND:hu,greater:sn,greaterEqual:rn,ifft:nn,imag:on,image:qt,inTopKAsync:yu,irfft:un,isFinite:ln,isInf:pn,isNaN:mn,leakyRelu:cn,less:dn,lessEqual:hn,linalg:fn,linspace:Zi,localResponseNormalization:yn,log:gn,log1p:bn,logSigmoid:Nn,logSoftmax:wn,logSumExp:Tn,logicalAnd:Sn,logicalNot:vn,logicalOr:On,logicalXor:_n,losses:En,lowerBound:Mi,matMul:W,max:An,maxPool:kn,maxPool3d:In,maxPoolWithArgmax:to,maximum:$n,mean:Dn,meshgrid:ao,min:Cn,minimum:zn,mirrorPad:Ln,mod:Fn,moments:xn,movingAverage:ou,mul:ae,multiRNNCell:ro,multinomial:io,neg:Vn,norm:Pn,notEqual:Rn,oneHot:Ce,ones:te,onesLike:jn,op:T,outerProduct:uo,pad:oe,pad1d:po,pad2d:co,pad3d:fo,pad4d:go,pool:Bn,pow:zt,prelu:Hn,print:Wn,prod:qn,raggedGather:No,raggedRange:To,raggedTensorToTensor:vo,rand:_o,randomGamma:xo,randomNormal:_t,randomStandardNormal:Po,randomUniform:Et,randomUniformInt:jo,range:Un,real:Gn,reciprocal:Kn,relu:Jn,relu6:Qn,reshape:v,reverse:ue,reverse1d:Ho,reverse2d:qo,reverse3d:Go,reverse4d:Jo,rfft:Xn,round:Zn,rsqrt:Yn,scalar:H,scatterND:lu,searchSorted:Ze,selu:Mn,separableConv2d:ei,setdiff1dAsync:Xo,sigmoid:ye,sign:ti,signal:ai,sin:si,sinh:ri,slice:U,slice1d:ni,slice2d:ii,slice3d:oi,slice4d:ui,softmax:li,softplus:pi,spaceToBatchND:mi,sparse:ci,sparseToDense:cu,spectral:di,split:hi,sqrt:fi,square:yi,squaredDifference:gi,squeeze:$t,stack:ie,step:bi,stridedSlice:Ni,string:wi,sub:ge,sum:Ti,tan:Si,tanh:De,tensor:G,tensor1d:Ut,tensor2d:ze,tensor3d:vi,tensor4d:Zo,tensor5d:Yo,tensor6d:Mo,tensorScatterUpdate:tu,tile:Oi,topk:_i,transpose:Bt,truncatedNormal:Ei,unique:Ai,unsortedSegmentSum:ki,unstack:le,upperBound:au,variable:Ii,where:$i,whereAsync:Zt,zeros:Di,zerosLike:Ci},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const op=(a,e,t,s=A)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(i("a",a,e,t),i("b",a,e,t))];case"AddN":return[s.addN(i("tensors",a,e,t))];case"FloorMod":case"Mod":return[s.mod(i("a",a,e,t),i("b",a,e,t))];case"Mul":return[s.mul(i("a",a,e,t),i("b",a,e,t))];case"RealDiv":case"Div":return[s.div(i("a",a,e,t),i("b",a,e,t))];case"DivNoNan":return[s.divNoNan(i("a",a,e,t),i("b",a,e,t))];case"FloorDiv":return[s.floorDiv(i("a",a,e,t),i("b",a,e,t))];case"Sub":return[s.sub(i("a",a,e,t),i("b",a,e,t))];case"Minimum":return[s.minimum(i("a",a,e,t),i("b",a,e,t))];case"Maximum":return[s.maximum(i("a",a,e,t),i("b",a,e,t))];case"Pow":return[s.pow(i("a",a,e,t),i("b",a,e,t))];case"SquaredDifference":return[s.squaredDifference(i("a",a,e,t),i("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const up=(a,e,t,s=A)=>{switch(a.op){case"Abs":case"ComplexAbs":return[s.abs(i("x",a,e,t))];case"Acos":return[s.acos(i("x",a,e,t))];case"Acosh":return[s.acosh(i("x",a,e,t))];case"Asin":return[s.asin(i("x",a,e,t))];case"Asinh":return[s.asinh(i("x",a,e,t))];case"Atan":return[s.atan(i("x",a,e,t))];case"Atan2":return[s.atan2(i("x",a,e,t),i("y",a,e,t))];case"Atanh":return[s.atanh(i("x",a,e,t))];case"Ceil":return[s.ceil(i("x",a,e,t))];case"Complex":return[s.complex(i("real",a,e,t),i("imag",a,e,t))];case"Cos":return[s.cos(i("x",a,e,t))];case"Cosh":return[s.cosh(i("x",a,e,t))];case"Elu":return[s.elu(i("x",a,e,t))];case"Erf":return[s.erf(i("x",a,e,t))];case"Exp":return[s.exp(i("x",a,e,t))];case"Expm1":return[s.expm1(i("x",a,e,t))];case"Floor":return[s.floor(i("x",a,e,t))];case"Log":return[s.log(i("x",a,e,t))];case"Log1p":return[s.log1p(i("x",a,e,t))];case"Imag":return[s.imag(i("x",a,e,t))];case"Neg":return[s.neg(i("x",a,e,t))];case"Reciprocal":return[s.reciprocal(i("x",a,e,t))];case"Real":return[s.real(i("x",a,e,t))];case"Relu":return[s.relu(i("x",a,e,t))];case"Round":return[s.round(i("x",a,e,t))];case"Selu":return[s.selu(i("x",a,e,t))];case"Sigmoid":return[s.sigmoid(i("x",a,e,t))];case"Sin":return[s.sin(i("x",a,e,t))];case"Sign":return[s.sign(i("x",a,e,t))];case"Sinh":return[s.sinh(i("x",a,e,t))];case"Softplus":return[s.softplus(i("x",a,e,t))];case"Sqrt":return[s.sqrt(i("x",a,e,t))];case"Square":return[s.square(i("x",a,e,t))];case"Tanh":return[s.tanh(i("x",a,e,t))];case"Tan":return[s.tan(i("x",a,e,t))];case"ClipByValue":return[s.clipByValue(i("x",a,e,t),i("clipValueMin",a,e,t),i("clipValueMax",a,e,t))];case"Relu6":return[s.relu6(i("x",a,e,t))];case"Rsqrt":return[s.rsqrt(E(a.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(i("x",a,e,t),i("alpha",a,e,t))];case"Prelu":return[s.prelu(i("x",a,e,t),i("alpha",a,e,t))];case"IsNan":return[s.isNaN(E(a.inputNames[0],e,t))];case"IsInf":return[s.isInf(E(a.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(E(a.inputNames[0],e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L(a,e,t=""){if(!(typeof a=="number"||typeof e=="number")){w(a.length===e.length,()=>t+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const r=a[s],n=e[s];w(r<0||n<0||r===n,()=>t+` Shapes ${a} and ${e} must match`)}}}function gt(a){return!(typeof a=="number"||a.some(e=>e<0))}function M(a,e,t){let s=Ue(a,t);const r=!gt(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(n=>{s=Ue(n.shape,s)}),!gt(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Ue(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const t=[];for(let s=0;s<a.length;++s){const r=a[s],n=e[s];if(r>=0&&n>=0&&r!==n)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);t[s]=r>=0?r:n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lp{constructor(e,t,s,r,n,u,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=n,this.dynamicSize=u,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=H(0),B(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),L(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,B(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return G([],[0].concat(this.elementShape));const s=this.readMany(e);return L(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),ie(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return G([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return L(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Oe(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,le(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const n=s===0?0:t.size/s,u=[];x(()=>{t=v(t,[1,s,n]);for(let l=0;l<e.length;++l){const m=[0,l===0?0:r[l-1],0],c=[1,e[l],n];u[l]=v(U(t,m,c),this.elementShape)}return u});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J{get id(){return this.idTensor.id}constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(n=>{if(s!==n.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${n.dtype}`);L(t,n.shape,"TensorList shape mismatch: "),B(n)}),this.idTensor=H(0),this.maxNumElements=r,B(this.idTensor)}copy(){return new J([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);L(e,this.elementShape,"TensorList shape mismatch: ");const r=M(this.elementShape,this.tensors,e);return x(()=>{const n=this.tensors.map(u=>v(u,r));return ie(n,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=M(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,L(r.shape,e,"TensorList shape mismatch: "),v(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(L(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");B(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new J([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);L(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=M(this.elementShape,this.tensors,t);return v(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);L(this.elementShape,t.shape,"TensorList shape mismatch: "),B(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);L(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=M(this.elementShape,this.tensors,s);return e.length===0?G([],[0].concat(r)):x(()=>{const n=e.map(u=>v(this.tensors[u],r));return ie(n,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);L(this.elementShape,t,"TensorList shape mismatch: ");const s=M(this.elementShape,this.tensors,t);return this.size()===0?G([],[0].concat(s)):x(()=>{const r=this.tensors.map(n=>v(n,s));return Oe(r,0)})}}function pp(a,e,t){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==t)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${t}`);const r=a.shape.slice(1);L(r,e,"TensorList shape mismatch: ");const n=le(a);return new J(n,e,s)}function mp(a,e,t,s){return new J([],a,e,s)}function cp(a,e,t,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const n=new J([],t,a.dtype,s),u=le(a,0);return e.forEach((o,l)=>{n.setItem(o,u[l])}),n}function dp(a,e,t){let s=0;const r=e.map(m=>(s+=m,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const n=a.shape.slice(1),u=Ue(n,t),o=s===0?0:a.size/s,l=x(()=>{const m=[];a=v(a,[1,s,o]);for(let c=0;c<e.length;++c){const h=[0,c===0?0:r[c-1],0],N=[1,e[c],o];m[c]=v(U(a,h,N),u)}return a.dispose(),m}),p=new J([],t,a.dtype,e.length);for(let m=0;m<l.length;m++)p.setItem(m,l[m]);return p}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hp=async(a,e,t)=>{switch(a.op){case"If":case"StatelessIf":{const s=i("thenBranch",a,e,t),r=i("elseBranch",a,e,t),n=i("cond",a,e,t),u=i("args",a,e,t);return(await n.data())[0]?t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=i("body",a,e,t),r=i("cond",a,e,t),n=i("args",a,e,t),u=await t.functionMap[r].executeFunctionAsync(n,t.tensorArrayMap,t.tensorListMap),o=n.map(m=>m.id);let l=await u[0].data();u.forEach(m=>{!m.kept&&o.indexOf(m.id)===-1&&m.dispose()});let p=n;for(;l[0];){const m=p;p=await t.functionMap[s].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);const c=p.map(h=>h.id);m.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&c.indexOf(h.id)===-1&&h.dispose()});const d=await t.functionMap[r].executeFunctionAsync(p,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(h=>{!h.kept&&o.indexOf(h.id)===-1&&c.indexOf(h.id)===-1&&h.dispose()})}return p}case"LoopCond":{const s=i("pred",a,e,t);return[j(s)]}case"Switch":{const s=i("pred",a,e,t);let r=i("data",a,e,t);return r.kept||(r=j(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=a.inputNames.find(r=>E(r,e,t)!==void 0);if(s){const r=E(s,e,t);return[j(r)]}return}case"Enter":{const s=i("frameName",a,e,t),r=i("tensor",a,e,t);return t.enterFrame(s),[j(r)]}case"Exit":{const s=i("tensor",a,e,t);return t.exitFrame(),[j(s)]}case"NextIteration":{const s=i("tensor",a,e,t);return t.nextIteration(),[j(s)]}case"TensorArrayV3":{const s=i("size",a,e,t),r=i("dtype",a,e,t),n=i("elementShape",a,e,t),u=i("dynamicSize",a,e,t),o=i("clearAfterRead",a,e,t),l=i("identicalElementShapes",a,e,t),p=i("name",a,e,t),m=new lp(p,r,s,n,l,u,o);return t.addTensorArray(m),[m.idTensor,H(1)]}case"TensorArrayWriteV3":{const s=i("tensorArrayId",a,e,t),r=i("index",a,e,t),n=i("tensor",a,e,t),u=t.getTensorArray(s.id);return u.write(r,n),[u.idTensor]}case"TensorArrayReadV3":{const s=i("tensorArrayId",a,e,t),r=i("index",a,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=i("tensorArrayId",a,e,t),r=i("indices",a,e,t),n=i("dtype",a,e,t);return[t.getTensorArray(s.id).gather(r,n)]}case"TensorArrayScatterV3":{const s=i("tensorArrayId",a,e,t),r=i("indices",a,e,t),n=i("tensor",a,e,t),u=t.getTensorArray(s.id);return u.scatter(r,n),[u.idTensor]}case"TensorArrayConcatV3":{const s=i("tensorArrayId",a,e,t),r=t.getTensorArray(s.id),n=i("dtype",a,e,t);return[r.concat(n)]}case"TensorArraySplitV3":{const s=i("tensorArrayId",a,e,t),r=i("tensor",a,e,t),n=i("lengths",a,e,t),u=t.getTensorArray(s.id);return u.split(n,r),[u.idTensor]}case"TensorArraySizeV3":{const s=i("tensorArrayId",a,e,t),r=t.getTensorArray(s.id);return[H(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=i("tensorArrayId",a,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=i("tensorListId",a,e,t),r=i("index",a,e,t),n=i("tensor",a,e,t),u=t.getTensorList(s.id);return u.setItem(r,n),[u.idTensor]}case"TensorListGetItem":{const s=i("tensorListId",a,e,t),r=i("index",a,e,t),n=i("elementShape",a,e,t),u=i("elementDType",a,e,t);return[t.getTensorList(s.id).getItem(r,n,u)]}case"TensorListScatterV2":case"TensorListScatter":{const s=i("indices",a,e,t),r=i("tensor",a,e,t),n=i("elementShape",a,e,t),u=i("numElements",a,e,t),o=cp(r,s,n,u);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=i("elementShape",a,e,t),r=i("elementDType",a,e,t);let n;a.op==="TensorListReserve"?n="numElements":n="maxNumElements";const u=i(n,a,e,t),o=a.op==="TensorListReserve"?-1:u,l=mp(s,r,u,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=i("tensorListId",a,e,t),r=i("indices",a,e,t),n=i("elementShape",a,e,t),u=i("elementDType",a,e,t);return[t.getTensorList(s.id).gather(r,u,n)]}case"TensorListStack":{const s=i("tensorListId",a,e,t),r=i("elementShape",a,e,t),n=i("elementDType",a,e,t),u=i("numElements",a,e,t);return[t.getTensorList(s.id).stack(r,n,u)]}case"TensorListFromTensor":{const s=i("tensor",a,e,t),r=i("elementShape",a,e,t),n=i("elementDType",a,e,t),u=pp(s,r,n);return t.addTensorList(u),[u.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=i("tensorListId",a,e,t),r=t.getTensorList(s.id),n=i("dtype",a,e,t),u=i("elementShape",a,e,t);return[r.concat(n,u)]}case"TensorListPushBack":{const s=i("tensorListId",a,e,t),r=i("tensor",a,e,t),n=t.getTensorList(s.id);return n.pushBack(r),[n.idTensor]}case"TensorListPopBack":{const s=i("tensorListId",a,e,t),r=i("elementShape",a,e,t),n=i("elementDType",a,e,t);return[t.getTensorList(s.id).popBack(r,n)]}case"TensorListSplit":{const s=i("tensor",a,e,t),r=i("elementShape",a,e,t),n=i("lengths",a,e,t),u=dp(s,n,r);return t.addTensorList(u),[u.idTensor]}case"TensorListLength":{const s=i("tensorListId",a,e,t),r=t.getTensorList(s.id);return[H(r.size(),"int32")]}case"TensorListResize":{const s=i("tensorListId",a,e,t),r=i("size",a,e,t),u=t.getTensorList(s.id).resize(r);return t.addTensorList(u),[u.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bt(a,e,t){const[s,r]=i("fusedOps",a,e,t),n=s==="biasadd",u=!n,o=r==="prelu",l=s==="fusedbatchnorm",p=i("numArgs",a,e,t);if(n){if(o&&p!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&n&&p!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const m=i("strides",a,e,t),c=be(a,e,t),d=i("dataFormat",a,e,t).toUpperCase(),h=i("dilations",a,e,t);let[N,g]=i("args",a,e,t);u&&(g=N,N=void 0);const f=i("leakyreluAlpha",a,e,t);return{stride:m,pad:c,dataFormat:d,dilations:h,biasArg:N,preluArg:g,activationFunc:r,leakyreluAlpha:f}}const fp=(a,e,t,s=A)=>{switch(a.op){case"Conv1D":{const r=i("stride",a,e,t),n=i("pad",a,e,t),u=i("dataFormat",a,e,t).toUpperCase(),o=i("dilation",a,e,t);return[s.conv1d(i("x",a,e,t),i("filter",a,e,t),r,n,u,o)]}case"Conv2D":{const r=i("strides",a,e,t),n=be(a,e,t),u=i("dataFormat",a,e,t).toUpperCase(),o=i("dilations",a,e,t);return[s.conv2d(i("x",a,e,t),i("filter",a,e,t),[r[1],r[2]],n,u,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:n,dataFormat:u,dilations:o,biasArg:l,preluArg:p,activationFunc:m,leakyreluAlpha:c}=bt(a,e,t);return[s.fused.conv2d({x:i("x",a,e,t),filter:i("filter",a,e,t),strides:[r[1],r[2]],pad:n,dataFormat:u,dilations:[o[1],o[2]],bias:l,activation:m,preluActivationWeights:p,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:n,dataFormat:u,dilations:o,biasArg:l,preluArg:p,activationFunc:m,leakyreluAlpha:c}=bt(a,e,t);return[s.fused.depthwiseConv2d({x:i("x",a,e,t),filter:i("filter",a,e,t),strides:[r[1],r[2]],pad:n,dataFormat:u,dilations:[o[1],o[2]],bias:l,activation:m,preluActivationWeights:p,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=i("outputShape",a,e,t),n=i("strides",a,e,t),u=be(a,e,t);return[s.conv2dTranspose(i("x",a,e,t),i("filter",a,e,t),r,[n[1],n[2]],u)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=i("strides",a,e,t),n=be(a,e,t),u=i("dilations",a,e,t),o=i("dataFormat",a,e,t).toUpperCase();return[s.depthwiseConv2d(i("input",a,e,t),i("filter",a,e,t),[r[1],r[2]],n,o,[u[1],u[2]])]}case"Conv3D":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("dataFormat",a,e,t).toUpperCase(),o=i("dilations",a,e,t);return[s.conv3d(i("x",a,e,t),i("filter",a,e,t),[r[1],r[2],r[3]],n,u,[o[1],o[2],o[3]])]}case"AvgPool":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("kernelSize",a,e,t);return[s.avgPool(i("x",a,e,t),[u[1],u[2]],[r[1],r[2]],n)]}case"MaxPool":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("kernelSize",a,e,t);return[s.maxPool(i("x",a,e,t),[u[1],u[2]],[r[1],r[2]],n)]}case"MaxPoolWithArgmax":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("kernelSize",a,e,t),o=i("includeBatchInIndex",a,e,t),{result:l,indexes:p}=s.maxPoolWithArgmax(i("x",a,e,t),[u[1],u[2]],[r[1],r[2]],n,o);return[l,p]}case"AvgPool3D":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("kernelSize",a,e,t);return[s.avgPool3d(i("x",a,e,t),[u[1],u[2],u[3]],[r[1],r[2],r[3]],n)]}case"MaxPool3D":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("kernelSize",a,e,t);return[s.maxPool3d(i("x",a,e,t),[u[1],u[2],u[3]],[r[1],r[2],r[3]],n)]}case"Dilation2D":{const r=i("strides",a,e,t),n=i("pad",a,e,t),u=i("dilations",a,e,t),o=r[1],l=r[2],p=u[1],m=u[2];return[s.dilation2d(i("x",a,e,t),i("filter",a,e,t),[o,l],n,[p,m],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yp=(a,e,t,s=A)=>{switch(a.op){case"Fill":{const r=i("shape",a,e,t),n=i("dtype",a,e,t),u=i("value",a,e,t);return[s.fill(r,u,n)]}case"LinSpace":{const r=i("start",a,e,t),n=i("stop",a,e,t),u=i("num",a,e,t);return[s.linspace(r,n,u)]}case"Multinomial":{const r=i("logits",a,e,t),n=i("numSamples",a,e,t),u=i("seed",a,e,t);return[s.multinomial(r,n,u)]}case"OneHot":{const r=i("indices",a,e,t),n=i("depth",a,e,t),u=i("onValue",a,e,t),o=i("offValue",a,e,t),l=i("dtype",a,e,t);return[s.oneHot(r,n,u,o,l)]}case"Ones":return[s.ones(i("shape",a,e,t),i("dtype",a,e,t))];case"OnesLike":return[s.onesLike(i("x",a,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(i("shape",a,e,t),i("dtype",a,e,t),i("seed",a,e,t))];case"RandomUniform":return[s.randomUniform(i("shape",a,e,t),i("minval",a,e,t),i("maxval",a,e,t),i("dtype",a,e,t))];case"RandomUniformInt":return[s.randomUniformInt(i("shape",a,e,t),i("minval",a,e,t),i("maxval",a,e,t),i("seed",a,e,t))];case"Range":{const r=i("start",a,e,t),n=i("stop",a,e,t),u=i("step",a,e,t);return[s.range(r,n,u,i("dtype",a,e,t))]}case"TruncatedNormal":{const r=i("shape",a,e,t),n=i("mean",a,e,t),u=i("stdDev",a,e,t),o=i("seed",a,e,t);return[s.truncatedNormal(r,n,u,i("dtype",a,e,t),o)]}case"Zeros":return[s.zeros(i("shape",a,e,t),i("dtype",a,e,t))];case"ZerosLike":return[s.zerosLike(i("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ie(a,e,t){const s=i("boxes",a,e,t),r=i("scores",a,e,t),n=i("maxOutputSize",a,e,t),u=i("iouThreshold",a,e,t),o=i("scoreThreshold",a,e,t),l=i("softNmsSigma",a,e,t);return{boxes:s,scores:r,maxOutputSize:n,iouThreshold:u,scoreThreshold:o,softNmsSigma:l}}const gp=async(a,e,t,s,r=A)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:u,maxOutputSize:o,iouThreshold:l,scoreThreshold:p,softNmsSigma:m}=Ie(a,e,t),c=await r.image.nonMaxSuppressionWithScoreAsync(n,u,o,l,p,m);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:u,maxOutputSize:o,iouThreshold:l,scoreThreshold:p}=Ie(a,e,t),m=i("padToMaxOutputSize",a,e,t),c=await r.image.nonMaxSuppressionPaddedAsync(n,u,o,l,p,m);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:u,maxOutputSize:o,iouThreshold:l,scoreThreshold:p}=Ie(a,e,t);return[await r.image.nonMaxSuppressionAsync(n,u,o,l,p)]}case"Where":{const n=r.cast(i("condition",a,e,t),"bool"),u=[await r.whereAsync(n)];return n.dispose(),u}case"ListDiff":return r.setdiff1dAsync(i("x",a,e,t),i("y",a,e,t));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bp=(a,e,t,s=A)=>{switch(a.op){case"LowerBound":{const r=i("sortedSequence",a,e,t),n=i("values",a,e,t);return[s.lowerBound(r,n)]}case"TopKV2":{const r=i("x",a,e,t),n=i("k",a,e,t),u=i("sorted",a,e,t),o=s.topk(r,n,u);return[o.values,o.indices]}case"UpperBound":{const r=i("sortedSequence",a,e,t),n=i("values",a,e,t);return[s.upperBound(r,n)]}case"Unique":{const r=i("x",a,e,t),n=s.unique(r);return[n.values,n.indices]}case"UniqueV2":{const r=i("x",a,e,t),n=i("axis",a,e,t),u=s.unique(r,n);return[u.values,u.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Np=(a,e,t,s=A)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const r=i("default",a,e,t);return[E(a.name,e,t)||r];case"Placeholder":return[E(a.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const m=i("x",a,e,t);return[j(m)]}case"IdentityN":return i("x",a,e,t).map(m=>j(m));case"Snapshot":const n=i("x",a,e,t);return[j(n)];case"Shape":return[s.tensor1d(i("x",a,e,t).shape,"int32")];case"ShapeN":return i("x",a,e,t).map(m=>s.tensor1d(m.shape));case"Size":return[s.scalar(i("x",a,e,t).size,"int32")];case"Rank":return[s.scalar(i("x",a,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const u=i("x",a,e,t),o=i("data",a,e,t),l=i("message",a,e,t),p=i("summarize",a,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let m=0;m<o.length;m++)console.log(Array.prototype.slice.call(o[m].dataSync()).slice(0,p));return[u];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wp{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=H(0),this.tensorMap=new Map,B(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return H(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),x(()=>{const r=le(t),n=s.length,u=r.length;w(n===u,()=>`The number of elements doesn't match, keys has ${n} elements, the values has ${u} elements.`);for(let o=0;o<n;o++){const l=s[o],p=r[o];B(p),this.tensorMap.set(l,p)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return x(()=>{const r=[];for(let n=0;n<s.length;n++){const u=s[n],o=this.findWithDefault(u,t);r.push(o)}return ie(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tp=async(a,e,t,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(a.name);if(r!=null)return[r];{const n=i("keyDType",a,e,t),u=i("valueDType",a,e,t),o=new wp(n,u);return s.addHashTable(a.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=i("tableHandle",a,e,t,s),n=i("keys",a,e,t),u=i("values",a,e,t);return[await s.getHashTableById(r.id).import(n,u)]}case"LookupTableFind":case"LookupTableFindV2":{const r=i("tableHandle",a,e,t,s),n=i("keys",a,e,t),u=i("defaultValue",a,e,t);return[await s.getHashTableById(r.id).find(n,u)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=i("tableHandle",a,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sp=(a,e,t,s=A)=>{switch(a.op){case"ResizeBilinear":{const r=i("images",a,e,t),n=i("size",a,e,t),u=i("alignCorners",a,e,t),o=i("halfPixelCenters",a,e,t);return[s.image.resizeBilinear(r,[n[0],n[1]],u,o)]}case"ResizeNearestNeighbor":{const r=i("images",a,e,t),n=i("size",a,e,t),u=i("alignCorners",a,e,t),o=i("halfPixelCenters",a,e,t);return[s.image.resizeNearestNeighbor(r,[n[0],n[1]],u,o)]}case"CropAndResize":{const r=i("image",a,e,t),n=i("boxes",a,e,t),u=i("boxInd",a,e,t),o=i("cropSize",a,e,t),l=i("method",a,e,t),p=i("extrapolationValue",a,e,t);return[s.image.cropAndResize(r,n,u,o,l,p)]}case"ImageProjectiveTransformV3":{const r=i("images",a,e,t),n=i("transforms",a,e,t),u=i("outputShape",a,e,t),o=i("fillValue",a,e,t),l=i("interpolation",a,e,t),p=i("fillMode",a,e,t);return[s.image.transform(r,n,l.toLowerCase(),p.toLowerCase(),o,u)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vp=(a,e,t,s=A)=>{switch(a.op){case"Equal":return[s.equal(i("a",a,e,t),i("b",a,e,t))];case"NotEqual":return[s.notEqual(i("a",a,e,t),i("b",a,e,t))];case"Greater":return[s.greater(i("a",a,e,t),i("b",a,e,t))];case"GreaterEqual":return[s.greaterEqual(i("a",a,e,t),i("b",a,e,t))];case"Less":return[s.less(i("a",a,e,t),i("b",a,e,t))];case"LessEqual":return[s.lessEqual(i("a",a,e,t),i("b",a,e,t))];case"LogicalAnd":return[s.logicalAnd(i("a",a,e,t),i("b",a,e,t))];case"LogicalNot":return[s.logicalNot(i("a",a,e,t))];case"LogicalOr":return[s.logicalOr(i("a",a,e,t),i("b",a,e,t))];case"Select":case"SelectV2":return[s.where(i("condition",a,e,t),i("a",a,e,t),i("b",a,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(i("a",a,e,t),i("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Op=(a,e,t,s=A)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(i("a",a,e,t),i("b",a,e,t),i("transposeA",a,e,t),i("transposeB",a,e,t))];case"Einsum":return[s.einsum(i("equation",a,e,t),...i("tensors",a,e,t))];case"Transpose":return[s.transpose(i("x",a,e,t),i("perm",a,e,t))];case"_FusedMatMul":const[r,n]=i("fusedOps",a,e,t),u=r==="biasadd",o=n==="prelu",l=i("numArgs",a,e,t),p=i("leakyreluAlpha",a,e,t);if(u){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[m,c]=i("args",a,e,t);return[s.fused.matMul({a:i("a",a,e,t),b:i("b",a,e,t),transposeA:i("transposeA",a,e,t),transposeB:i("transposeB",a,e,t),bias:m,activation:n,preluActivationWeights:c,leakyreluAlpha:p})];case"MatrixBandPart":return[s.linalg.bandPart(i("a",a,e,t),i("numLower",a,e,t),i("numUpper",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _p=(a,e,t,s=A)=>{switch(a.op){case"EuclideanNorm":return[s.euclideanNorm(i("x",a,e,t),i("axis",a,e,t),i("keepDims",a,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(i("x",a,e,t),i("mean",a,e,t),i("variance",a,e,t),i("offset",a,e,t),i("scale",a,e,t),i("epsilon",a,e,t))];case"FusedBatchNormV3":return[s.batchNorm(i("x",a,e,t),i("mean",a,e,t),i("variance",a,e,t),i("offset",a,e,t),i("scale",a,e,t),i("epsilon",a,e,t))];case"LRN":return[s.localResponseNormalization(i("x",a,e,t),i("radius",a,e,t),i("bias",a,e,t),i("alpha",a,e,t),i("beta",a,e,t))];case"Softmax":return[s.softmax(i("x",a,e,t))];case"LogSoftmax":return[s.logSoftmax(i("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ep=(a,e,t,s=A)=>{switch(a.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:n}=s.raggedGather(i("paramsNestedSplits",a,e,t),i("paramsDenseValues",a,e,t),i("indices",a,e,t),i("outputRaggedRank",a,e,t));return r.concat(n)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:n}=s.raggedRange(i("starts",a,e,t),i("limits",a,e,t),i("splits",a,e,t));return[r,n]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(i("shape",a,e,t),i("values",a,e,t),i("defaultValue",a,e,t),i("rowPartitionTensors",a,e,t),i("rowPartitionTypes",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ap=(a,e,t,s=A)=>{switch(a.op){case"Max":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.max(i("x",a,e,t),o,l)]}case"Mean":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.mean(i("x",a,e,t),o,l)]}case"Min":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.min(i("x",a,e,t),o,l)]}case"Sum":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.sum(i("x",a,e,t),o,l)]}case"All":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.all(i("x",a,e,t),o,l)]}case"Any":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.any(i("x",a,e,t),o,l)]}case"ArgMax":{const o=i("axis",a,e,t);return[s.argMax(i("x",a,e,t),o)]}case"ArgMin":{const o=i("axis",a,e,t);return[s.argMin(i("x",a,e,t),o)]}case"Prod":{const o=i("axis",a,e,t),l=i("keepDims",a,e,t);return[s.prod(i("x",a,e,t),o,l)]}case"Cumprod":{const o=i("axis",a,e,t),l=i("exclusive",a,e,t),p=i("reverse",a,e,t);return[s.cumprod(i("x",a,e,t),o,l,p)]}case"Cumsum":{const o=i("axis",a,e,t),l=i("exclusive",a,e,t),p=i("reverse",a,e,t);return[s.cumsum(i("x",a,e,t),o,l,p)]}case"Bincount":const r=i("x",a,e,t),n=i("weights",a,e,t),u=i("size",a,e,t);return[s.bincount(r,n,u)];case"DenseBincount":{const o=i("x",a,e,t),l=i("weights",a,e,t),p=i("size",a,e,t),m=i("binaryOutput",a,e,t);return[s.denseBincount(o,l,p,m)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kp=(a,e,t,s=A)=>{switch(a.op){case"ConcatV2":case"Concat":{const r=i("n",a,e,t),n=i("axis",a,e,t);let u=i("tensors",a,e,t);return u=u.slice(0,r),[s.concat(u,n)]}case"Gather":{const r=i("x",a,e,t),n=i("indices",a,e,t);return[s.gather(r,s.cast(n,"int32"),0)]}case"GatherV2":{const r=i("axis",a,e,t),n=i("batchDims",a,e,t),u=i("x",a,e,t),o=i("indices",a,e,t);return[s.gather(u,s.cast(o,"int32"),r,n)]}case"Reverse":{const r=i("dims",a,e,t),n=[];for(let o=0;o<r.length;o++)r[o]&&n.push(o);const u=i("x",a,e,t);return[s.reverse(u,n)]}case"ReverseV2":{const r=i("axis",a,e,t),n=i("x",a,e,t);return[s.reverse(n,r)]}case"Slice":{const r=i("begin",a,e,t),n=i("size",a,e,t);return[s.slice(i("x",a,e,t),r,n)]}case"StridedSlice":{const r=i("begin",a,e,t),n=i("end",a,e,t),u=i("strides",a,e,t),o=i("beginMask",a,e,t),l=i("endMask",a,e,t),p=i("ellipsisMask",a,e,t),m=i("newAxisMask",a,e,t),c=i("shrinkAxisMask",a,e,t),d=i("x",a,e,t);return[s.stridedSlice(d,r,n,u,o,l,p,m,c)]}case"Pack":return x(()=>{const r=i("axis",a,e,t),n=i("tensors",a,e,t),u=n[0].shape,o=s.squeeze(n[0]).shape,l=n.map(p=>{const m=Y(p.shape,u);if(!m&&!Y(s.squeeze(p).shape,o))throw new Error("the input tensors shape does not match");return m?p:s.reshape(p,u)});return[s.stack(l,r)]});case"Unpack":{const r=i("axis",a,e,t),n=i("tensor",a,e,t);return s.unstack(n,r)}case"Tile":{const r=i("reps",a,e,t);return[s.tile(i("x",a,e,t),r)]}case"Split":case"SplitV":{const r=i("axis",a,e,t),n=i("numOrSizeSplits",a,e,t),u=i("x",a,e,t);return s.split(u,n,r)}case"ScatterNd":{const r=i("indices",a,e,t),n=i("values",a,e,t),u=i("shape",a,e,t);return[s.scatterND(r,n,u)]}case"GatherNd":{const r=i("x",a,e,t),n=i("indices",a,e,t);return[s.gatherND(r,n)]}case"SparseToDense":{const r=i("sparseIndices",a,e,t),n=i("outputShape",a,e,t),u=i("sparseValues",a,e,t),o=i("defaultValue",a,e,t);return[s.sparseToDense(r,u,n,u.dtype===o.dtype?o:s.cast(o,u.dtype))]}case"TensorScatterUpdate":{const r=i("indices",a,e,t),n=i("values",a,e,t),u=i("tensor",a,e,t);return[s.tensorScatterUpdate(u,r,n)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ip=(a,e,t,s=A)=>{switch(a.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:n,emptyRowIndicator:u,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(i("indices",a,e,t),i("values",a,e,t),i("denseShape",a,e,t),i("defaultValue",a,e,t));return[r,n,u,o]}case"SparseReshape":{const{outputIndices:r,outputShape:n}=s.sparse.sparseReshape(i("inputIndices",a,e,t),i("inputShape",a,e,t),i("newShape",a,e,t));return[r,n]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(i("data",a,e,t),i("indices",a,e,t),i("segmentIds",a,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(i("data",a,e,t),i("indices",a,e,t),i("segmentIds",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $p=(a,e,t,s=A)=>{switch(a.op){case"FFT":return[s.fft(i("x",a,e,t))];case"IFFT":return[s.ifft(i("x",a,e,t))];case"RFFT":return[s.rfft(i("x",a,e,t))];case"IRFFT":return[s.irfft(i("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dp=(a,e,t,s=A)=>{switch(a.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(i("input",a,e,t),i("pattern",a,e,t),i("rewrite",a,e,t),i("replaceGlobal",a,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:n}=s.string.stringNGrams(i("data",a,e,t),i("dataSplits",a,e,t),i("separator",a,e,t),i("nGramWidths",a,e,t),i("leftPad",a,e,t),i("rightPad",a,e,t),i("padWidth",a,e,t),i("preserveShortSequences",a,e,t));return[r,n]}case"StringSplit":{const{indices:r,values:n,shape:u}=s.string.stringSplit(i("input",a,e,t),i("delimiter",a,e,t),i("skipEmpty",a,e,t));return[r,n,u]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(i("input",a,e,t),i("numBuckets",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cp=(a,e,t,s=A)=>{switch(a.op){case"Cast":return[s.cast(i("x",a,e,t),i("dtype",a,e,t))];case"ExpandDims":{const r=i("axis",a,e,t);return[s.expandDims(i("x",a,e,t),r)]}case"Squeeze":{const r=i("axis",a,e,t);return[s.squeeze(i("x",a,e,t),r)]}case"Reshape":return[s.reshape(i("x",a,e,t),i("shape",a,e,t))];case"EnsureShape":return[s.ensureShape(i("x",a,e,t),i("shape",a,e,t))];case"MirrorPad":return[s.mirrorPad(i("x",a,e,t),i("padding",a,e,t),i("mode",a,e,t))];case"PadV2":case"Pad":return[s.pad(i("x",a,e,t),i("padding",a,e,t),i("constantValue",a,e,t))];case"SpaceToBatchND":{const r=i("blockShape",a,e,t),n=i("paddings",a,e,t);return[s.spaceToBatchND(i("x",a,e,t),r,n)]}case"BatchToSpaceND":{const r=i("blockShape",a,e,t),n=i("crops",a,e,t);return[s.batchToSpaceND(i("x",a,e,t),r,n)]}case"DepthToSpace":{const r=i("blockSize",a,e,t),n=i("dataFormat",a,e,t).toUpperCase();return[s.depthToSpace(i("x",a,e,t),r,n)]}case"BroadcastTo":return[s.broadcastTo(i("x",a,e,t),i("shape",a,e,t))];case"BroadcastArgs":return[s.broadcastArgs(i("s0",a,e,t),i("s1",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nt(a,e,t,s,r=x){const n=((u,o,l)=>{switch(u.category){case"arithmetic":return r(()=>op(u,o,l));case"basic_math":return r(()=>up(u,o,l));case"control":return hp(u,o,l);case"convolution":return r(()=>fp(u,o,l));case"creation":return r(()=>yp(u,o,l));case"dynamic":return gp(u,o,l);case"evaluation":return r(()=>bp(u,o,l));case"image":return r(()=>Sp(u,o,l));case"graph":return r(()=>Np(u,o,l));case"logical":return r(()=>vp(u,o,l));case"matrices":return r(()=>Op(u,o,l));case"normalization":return r(()=>_p(u,o,l));case"ragged":return r(()=>Ep(u,o,l));case"reduction":return r(()=>Ap(u,o,l));case"slice_join":return r(()=>kp(u,o,l));case"sparse":return r(()=>Ip(u,o,l));case"spectral":return r(()=>$p(u,o,l));case"string":return r(()=>Dp(u,o,l));case"transformation":return r(()=>Cp(u,o,l));case"hash_table":return Tp(u,o,l,s);case"custom":const p=ea(u.op);if(p&&p.customExecutor)return p.customExecutor(new ip(u,o,l));throw TypeError(`Custom op ${u.op} is not registered.`);default:throw TypeError(`Unknown op '${u.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,t);return we(n)?n.then(u=>[].concat(u)):[].concat(n)}class wt{constructor(e={},t={},s={},r={},n){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(a,e,t,s){const r=new Set,n=[];let u=null,o=null;const l=new Set,p=new Set(Object.keys(a).map(d=>$(d)[0]));s=s||[];const m=new Set(s.map(d=>$(d.name)[0])),c=[...e];for(;c.length>0;){const d=c.pop();if((q(d)||jp(d)||Bp(d))&&u==null&&(u=d,o=u.children.map(h=>h.name).filter(h=>r.has(h))),r.add(d.name),t[d.name]==null&&!p.has(d.name)&&!m.has(d.name)){if(d.inputs.length===0){n.push(d.name);continue}d.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),c.push(h))})}}return{inputs:a,outputs:e,usedNodes:r,missingInputs:n,dynamicNode:u,syncInputs:o}}function zp(a,e){const{usedNodes:t,inputs:s}=e,r=Object.keys(s).map(f=>$(f)[0]).map(f=>a.nodes[f]),n=a.initNodes||[],u=f=>t.has(typeof f=="string"?f:f.name);function o(f){return[...new Map(f.map(b=>[b.name,b])).values()]}const l=o([...r,...a.weights,...n]).filter(u),p=o([...l,...Object.values(a.nodes)]).filter(u),m=new Map(p.map(f=>[f.name,f])),c={};for(const f of p){c[f.name]=c[f.name]||0;for(const b of f.children)u(b)||(c[b.name]=Number.POSITIVE_INFINITY),c[b.name]=(c[b.name]||0)+1}const d=Object.entries(c).filter(([,f])=>f===0).map(([f])=>f),h=[...d];for(;d.length>0;){const f=d.pop(),b=m.get(f);for(const O of b.children.filter(u))--c[O.name]===0&&(h.push(O.name),d.push(O.name))}const N=h.map(f=>m.get(f)),g=Lp(N,l);return Fp(g,l),g}function Lp(a,e){const t=new Map(a.map(u=>[u.name,u])),s=e.map(u=>u.name),r=new Set(s);for(;s.length>0;){const u=s.pop(),o=t.get(u);for(const l of o.children)!t.has(l.name)||r.has(l.name)||(r.add(l.name),s.push(l.name))}return a.filter(u=>r.has(u.name))}class de extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Fp(a,e){const t=new Map(a.map((o,l)=>[o.name,l])),s=new Set(e.map(o=>o.name)),r=o=>s.has(typeof o=="string"?o:o.name),n=new Set(a.map(o=>o.name)),u=o=>n.has(typeof o=="string"?o:o.name);for(const o of a){for(const l of o.children.filter(u)){if(!t.has(l.name))throw new de(`Child ${l.name} of node ${o.name} is unreachable.`);if(t.get(o.name)>t.get(l.name))throw new de(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!r(o))for(const l of o.inputs){if(!t.has(l.name))throw new de(`Input ${l.name} of node ${o.name} is unreachable.`);if(t.get(l.name)>t.get(o.name))throw new de(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function xp(a){const e=new Map(a.map((o,l)=>[o.name,l])),t=Number.MAX_SAFE_INTEGER,s=a.map((o,l)=>q(o)?t:l),r=o=>{const l=s[e.get(o.name)];return l??-1},n=a.map((o,l)=>o.children.map(r).reduce((p,m)=>Math.max(p,m),s[l])),u=new Map;for(let o=0;o<a.length;++o){const l=n[o];if(l===t)continue;const p=a[o],m=a[l];u.has(m.name)||u.set(m.name,[]),u.get(m.name).push(p)}return u}const Vp=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Pp=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Rp=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function q(a){return Vp.has(a.op)}function jp(a){return Pp.has(a.op)}function Bp(a){return Rp.has(a.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ve{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new ve(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(n=>n.name).sort(),r=t.map(n=>n.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const s=Tt(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:n,syncInputs:u}=s;if(n!=null)throw new Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${u}]`);if(r.length>0){const p=t.map(c=>c.name),m=Object.keys(e);throw new Error(`Cannot compute the outputs [${p}] from the provided inputs [${m}]. Missing the following inputs: [${r}]`)}const o=zp(this.graph,s),l=xp(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return B(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(d=>this.graph.nodes[$(d)[0]]),n=t.map(d=>$(d)[0]),u=new Set(n);let o=n.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);const l=this.getCompilationKey(r,o);let p=this.compiledMap.get(l);p==null&&(p=this.compile(e,o),this.compiledMap.set(l,p));try{this.keepIntermediateTensors=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const m={},c={};return x(()=>{const d=new wt(this.weightMap,m,c,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(b=>{const[O,I]=$(b,d),S=[];S[I]=e[b],h[O]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[O]=this.cloneTensorList(S))});const N=this.getFrozenTensorIds(h),{orderedNodes:g,nodeLiveUntilMap:f}=p;for(const b of g){if(h[b.name])continue;const O=Nt(b,h,d,this._resourceManager);if(we(O))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);h[b.name]=O,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(O)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,h,d,N,u,f.get(b.name))}return this.parent==null&&d.dispose(N),t.map(b=>E(b,h,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,n,u,o){if(!(q(t)||u.has(e))){for(const l of s[e])l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length);for(const l of t.inputs){if(q(l))continue;const p=ht(l.name,s,r);if(p!=null)for(const m of p){if(!m||m.kept||n.has(m.id))continue;const c=o[m.id];c===1?(m.dispose(),delete o[m.id]):c!=null&&o[m.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,r,n,u){function o(l){return q(l)||n.has(l.name)}if(!(q(e)||u==null))for(const l of u){if(o(l))continue;const p=ht(l.name,t,s);for(const m of p)!m||m.kept||r.has(m.id)||m.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,r={},n={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=V().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const u=new wt(this.weightMap,r,n,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,u,t,s),l=t.map(d=>E(d,o,u)),p=l.map(d=>d.id),m=Object.keys(e).map(d=>e[d].id),c=new Set([...p,...m,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(h=>{h&&!h.isDisposed&&!c.has(h.id)&&h.dispose()})}),this.parent==null&&u.dispose(c),l}async executeFunctionAsync(e,t,s){const r=e.reduce((n,u,o)=>(n[this.inputs[o].name]=u,n),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const n=Object.keys(e),u=n.map(S=>this.graph.nodes[$(S)[0]]),o=s.map(S=>$(S)[0]),l=new Set(o);let p=o.map(S=>this.graph.nodes[S]);p.length===0&&(p=this._outputs);const{usedNodes:m,missingInputs:c,dynamicNode:d,syncInputs:h}=Tt(e,p,this.weightMap,this._initNodes),N=[...u,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[k,D]=$(S),C=[];C[D]=e[S],g[k]=C});const f={},b=this.getFrozenTensorIds(g),O={};for(;N.length>0;){const S=this.processStack(u,N,t,g,O,b,l,f,m);await Promise.all(S)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const I=p.filter(S=>!q(S)&&!E(S.name,g,t)).map(S=>S.name);if(I.length>0){let S="";throw d!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${I}] from the provided inputs [${n}]. Consider providing the following inputs: [${c}]. ${S}`)}return g}processStack(e,t,s,r,n,u,o,l,p){const m=[];for(;t.length>0;){const c=t.pop();s.currentContext=c.contexts;let d="";if(c.node.op==="Enter"&&i("isConstant",c.node,r,s)&&([d]=R(c.node.name,s)),r[c.node.name]==null){const h=Nt(c.node,r,s,this._resourceManager);d||([d]=R(c.node.name,s));const N=s.currentContext;we(h)?m.push(h.then(g=>(r[d]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(g)),s.currentContext=N,this.checkTensorForDisposal(d,c.node,r,s,u,o,l),this.processChildNodes(c.node,t,s,r,n,p),g))):(r[d]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(h)),this.checkTensorForDisposal(d,c.node,r,s,u,o,l),this.processChildNodes(c.node,t,s,r,n,p))}else this.processChildNodes(c.node,t,s,r,n,p)}return m}processChildNodes(e,t,s,r,n,u){e.children.forEach(o=>{const[l]=R(o.name,s);n[l]||!u.has(o.name)||(o.op==="Merge"?o.inputNames.some(p=>!!E(p,r,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(p=>!!E(p,r,s))&&(n[l]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=$(t),n=this.graph.nodes[r];if(n.attrParams.shape&&n.attrParams.shape.value){const u=n.attrParams.shape.value,o=u.length===s.shape.length&&s.shape.every((l,p)=>u[p]===-1||u[p]===l);w(o,()=>`The shape of dict['${n.name}'] provided in model.execute(dict) must be [${u}], but was [${s.shape}]`)}n.attrParams.dtype&&n.attrParams.dtype.value&&w(s.dtype===n.attrParams.dtype.value,()=>`The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const r={};for(const n in e){const u=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[n];u!=null?r[u.name]=e[n]:r[n]=e[n]}return r}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=$(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,r;const n=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[t];return n!=null?n.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=$(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class Hp{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wp="?tfjs-format=file",qp="model.json";class sa{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=Mt){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new Hp}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return we(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Pt(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const n=this.artifacts.userDefinedMetadata;n.signature!=null&&(r=n.signature),n.structuredOutputKeys!=null&&(this.structuredOutputKeys=n.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new ve(ft.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const n=ft.Instance.transformGraph(e.modelInitializer);this.initializer=new ve(n),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Ne?[e]:e,s={};return t.forEach((r,n)=>s[this.structuredOutputKeys[n]]=r),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Ne)&&!Array.isArray(e)){const n=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(n!=null)for(const u in n){const o=n[u];o.resourceId!=null&&(e[u]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((n,u)=>{var o,l,p;const m=(p=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[u])===null||p===void 0?void 0:p.resourceId;return m!=null?n[u]=this.resourceIdToCapturedInput[m]:n[u]=e[r++],n},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let r=0;r<s.length;r++){const n=s[r],u=t[n];this.resourceIdToCapturedInput[u.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&zi(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Tm(a,e={},t=Mt){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof a=="string"&&(a=Up(a));const s=new sa(a,e,t);return await s.load(),s}function Sm(a){if(a==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(a instanceof Array){const[s,r]=a;if(!s)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const n=jt(s.weightsManifest),u=Rt(s,n,r);e=Te(u)}else if("load"in a)e=a;else if("modelTopology"in a&&"weightSpecs"in a&&"weightData"in a)e=Te(a);else throw new Error("Unknown model format");const t=new sa(e);return t.load(),t}function Up(a){return a.endsWith("/")||(a=a+"/"),`${a}${qp}${Wp}`}/** @license See the LICENSE file. */const Gp="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ra extends Xe{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(r=>(r.endsWith("\r")&&(r=r.slice(0,-1)),r))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const he='"',ee=Symbol("out"),St=Symbol("field"),fe=Symbol("quote"),$e=Symbol("quoteafterquote"),vt=Symbol("quoteinquote");class na extends Xe{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&w(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((r,n)=>(r[n]=r[n]+1||1,r),{}),s=Object.keys(t).filter(r=>t[r]>1);if(w(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new ra(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(w(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},r={};for(let n=0;n<this.fullColumnNames.length;n++){const u=this.fullColumnNames[n],o=this.columnConfigs?this.columnConfigs[u]:null;if(!(this.configuredColumnsOnly&&!o)){const l=t[n];let p=null;if(l==="")if(o&&o.default!==void 0)p=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${u} is empty in this line: ${e}`);p=void 0}else{const m=Number(l);if(isNaN(m))o&&o.dtype==="bool"?p=this.getBoolean(l):p=l;else if(!o||!o.dtype)p=m;else switch(o.dtype){case"float32":p=m;break;case"int32":p=Math.floor(m);break;case"bool":p=this.getBoolean(l);break;default:p=m}}o&&o.isLabel?r[u]=p:s[u]=p}}return Object.keys(r).length===0?s:{xs:s,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let r=0;const n=e.length;let u=ee;for(let o=0;o<n;o++)switch(u){case ee:switch(e.charAt(o)){case he:r=o+1,u=fe;break;case this.delimiter:if(r=o+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),u=ee;break;default:u=St,r=o;break}break;case St:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(r,o)),u=ee,r=o+1;break}break;case fe:switch(e.charAt(o)){case he:u=$e;break}break;case $e:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(r,o-1)),u=ee,r=o+1;break;case he:u=fe;break;default:u=vt;break}break;case vt:switch(e.charAt(o)){case he:u=fe;break}break}if(u===$e?s.push(e.substring(r,n-1)):s.push(e.substring(r)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class at extends Ee{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!V().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new at(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const r=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(r,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const r=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(r,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(r=>{const n=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(n),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((r,n)=>s.set(r,n*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(re(t));return s.set(e,s.length-e.length),G(s,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class st extends Ee{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Ut([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,r=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,n=(1-s)/2,u=(1-r)/2,o=n+s,l=r+u;this.cropBox=ze([u,n,l,o],[1,4])}else this.cropBox=ze([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!V().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new st(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&w(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Li(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return x(()=>{const t=Wt(se(e,"float32"),0);let s;s=qt.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=s.shape;return v(s,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ia{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class oa extends Ee{split(e){return new Kp(this,e)}}class Kp extends oa{constructor(e,t){super(),this.upstream=e,this.impl=new Jp(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Jp extends Gt{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Qp extends Ee{decodeUTF8(){return new Xp(this)}}class Xp extends oa{constructor(e){super(),this.upstream=e,this.impl=new Zp(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class Zp extends Gt{constructor(e){if(super(),this.upstream=e,V().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return V().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ua extends Qp{constructor(e,t={}){super(),this.file=e,this.options=t,w(e instanceof Uint8Array||(V().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,s)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,r)));else{const n=new FileReader;n.onload=o=>{let l=n.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return s(new TypeError("FileReader returned unknown type."));t(l)},n.onabort=o=>s(new Error("Aborted")),n.onerror=o=>s(new Error(o.type));const u=this.file.slice(this.offset,r);n.readAsArrayBuffer(u)}this.offset=r}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function Yp(a,e={},t){let s,r;typeof a=="string"?s=a:(s=a.url,r=Mp(a));const n=await Fi(s,r);if(n.ok){const u=new Uint8Array(await n.arrayBuffer());return new ua(u,e)}else throw new Error(n.statusText)}const Mp=a=>({method:a.method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function la(a){return typeof a=="string"&&a.slice(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class pa extends ia{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(la(this.input)&&V().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new ua(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class ma extends ia{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return la(this.url)?new pa(this.url,this.fileOptions).iterator():Yp(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function em(a,e={}){return new na(new ma(a),e)}function tm(a){const e=Kt(a);return Jt(async()=>e)}function am(a){return Jt(async()=>{const e=await a();return Kt(()=>e.next())})}async function sm(a,e){return st.create(a,e)}async function rm(a){return at.create(a)}/** @license See the LICENSE file. */const ca="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vm=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:na,Dataset:Xe,FileDataSource:pa,TextLineDataset:ra,URLDataSource:ma,array:xi,csv:em,func:tm,generator:am,microphone:rm,version_data:ca,webcam:sm,zip:Vi},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const nm="4.22.0";/** @license See the LICENSE file. */const im="4.22.0";/** @license See the LICENSE file. */const om="4.22.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Om={"tfjs-core":zu,"tfjs-backend-cpu":nm,"tfjs-backend-webgl":im,"tfjs-data":ca,"tfjs-layers":Pi,"tfjs-converter":Gp,tfjs:om};export{Am as Abs,km as Acos,Im as Acosh,$m as AdadeltaOptimizer,Dm as AdagradOptimizer,Cm as AdamOptimizer,zm as AdamaxOptimizer,Lm as Add,ha as AddN,Fm as All,xm as Any,Vm as ArgMax,Pm as ArgMin,Rm as Asin,jm as Asinh,Bm as Atan,Hm as Atan2,Wm as Atanh,qm as AvgPool,Um as AvgPool3D,Gm as AvgPool3DGrad,Km as AvgPoolGrad,Jm as BatchMatMul,Qm as BatchToSpaceND,Xm as Bincount,fa as BitwiseAnd,ya as BroadcastArgs,Zm as BroadcastTo,bl as Callback,Ym as CallbackList,Mm as Cast,ec as Ceil,tc as ClipByValue,ac as Complex,sc as ComplexAbs,rc as Concat,nc as Conv2D,ic as Conv2DBackpropFilter,oc as Conv2DBackpropInput,uc as Conv3D,lc as Conv3DBackpropFilterV2,pc as Conv3DBackpropInputV2,mc as Cos,cc as Cosh,dc as CropAndResize,hc as Cumprod,fc as Cumsum,yc as CustomCallback,gc as DataStorage,bc as DenseBincount,Nc as DepthToSpace,wc as DepthwiseConv2dNative,Tc as DepthwiseConv2dNativeBackpropFilter,Sc as DepthwiseConv2dNativeBackpropInput,ga as Diag,vc as Dilation2D,Oc as Dilation2DBackpropFilter,_c as Dilation2DBackpropInput,Ec as Draw,Ac as ENV,Nl as EarlyStopping,kc as Einsum,Ic as Elu,$c as EluGrad,Dc as Environment,Cc as Equal,zc as Erf,Lc as Exp,Fc as ExpandDims,xc as Expm1,Vc as FFT,Pc as Fill,Rc as FlipLeftRight,jc as Floor,Bc as FloorDiv,Hc as FromPixels,Wc as FusedBatchNorm,qc as FusedConv2D,pt as FusedDepthwiseConv2D,Uc as GPGPUContext,Ca as GatherNd,Gc as GatherV2,sa as GraphModel,Kc as Greater,Jc as GreaterEqual,Qc as History,Xc as IFFT,Zc as Identity,Yc as Imag,Mc as InputSpec,ed as IsFinite,td as IsInf,ad as IsNan,sd as KernelBackend,rd as LRN,nd as LRNGrad,id as LayerVariable,Qs as LayersModel,od as LeakyRelu,ud as Less,ld as LessEqual,Na as LinSpace,pd as Log,md as Log1p,cd as LogSoftmax,dd as LogicalAnd,hd as LogicalNot,fd as LogicalOr,yd as LogicalXor,gd as LowerBound,bd as MathBackendCPU,Nd as MathBackendWebGL,wd as MatrixBandPart,Td as Max,Sd as MaxPool,vd as MaxPool3D,Od as MaxPool3DGrad,_d as MaxPoolGrad,Ta as MaxPoolWithArgmax,Ed as Maximum,Ad as Mean,kd as Min,Id as Minimum,$d as MirrorPad,Dd as Mod,Cd as MomentumOptimizer,Sa as Multinomial,zd as Multiply,Ld as Neg,Fd as NonMaxSuppressionV3,xd as NonMaxSuppressionV4,Vd as NonMaxSuppressionV5,Pd as NotEqual,Ms as OP_SCOPE_SUFFIX,Rd as OneHot,jd as OnesLike,Bd as Optimizer,Hd as OptimizerConstructors,Wd as Pack,qd as PadV2,Ud as Pool,Gd as Pow,Kd as Prelu,Jd as Prod,Qd as RMSPropOptimizer,Xd as RNN,va as RaggedGather,Oa as RaggedRange,_a as RaggedTensorToTensor,Zd as Range,Yd as Rank,Md as Real,eh as RealDiv,th as Reciprocal,ah as Reduction,sh as Relu,rh as Relu6,nh as Reshape,ih as ResizeBilinear,oh as ResizeBilinearGrad,uh as ResizeNearestNeighbor,lh as ResizeNearestNeighborGrad,ph as Reverse,mh as RotateWithOffset,ch as Round,dh as Rsqrt,hh as SGDOptimizer,$a as ScatterNd,wa as SearchSorted,fh as Select,yh as Selu,gh as Sequential,bh as Sigmoid,Nh as Sign,wh as Sin,Th as Sinh,Sh as Slice,vh as Softmax,Oh as Softplus,_h as SpaceToBatchND,Eh as SparseFillEmptyRows,Ah as SparseReshape,kh as SparseSegmentMean,Ih as SparseSegmentSum,Da as SparseToDense,$h as SplitV,Dh as Sqrt,Ch as Square,zh as SquaredDifference,Lh as StaticRegexReplace,Fh as Step,xh as StridedSlice,Vh as StringNGrams,Ph as StringSplit,Rh as StringToHashBucketFast,jh as Sub,Bh as Sum,Hh as SymbolicTensor,Wh as Tan,qh as Tanh,Ne as Tensor,ut as TensorBuffer,ka as TensorScatterUpdate,Uh as Tile,Gh as TopK,Kh as Transform,Jh as Transpose,Qh as Unique,Xh as Unpack,Zh as UnsortedSegmentSum,Yh as UpperBound,Mh as Variable,ef as ZerosLike,tf as _FusedMatMul,er as abs,tr as acos,ar as acosh,Z as add,ji as addN,sr as all,rr as any,nr as argMax,ir as argMin,or as asin,ur as asinh,lr as atan,pr as atan2,mr as atanh,cr as avgPool,dr as avgPool3d,af as backend,sf as backend_util,Hi as basicLSTMCell,hr as batchNorm,fr as batchNorm2d,yr as batchNorm3d,gr as batchNorm4d,br as batchToSpaceND,Nr as bincount,qi as bitwiseAnd,nu as booleanMaskAsync,Gi as broadcastArgs,wr as broadcastTo,rf as broadcast_util,nf as browser,Ot as buffer,bm as callbacks,se as cast,Tr as ceil,Sr as clipByValue,Ht as clone,vr as complex,Oe as concat,Or as concat1d,_r as concat2d,Er as concat3d,Ar as concat4d,dm as constraints,kr as conv1d,Ir as conv2d,$r as conv2dTranspose,Dr as conv3d,Cr as conv3dTranspose,of as copyRegisteredKernels,zr as cos,Lr as cosh,Fr as cosineWindow,xr as cumprod,Vr as cumsum,lt as customGrad,vm as data,Pr as denseBincount,uf as deprecationWarn,Rr as depthToSpace,Lt as depthwiseConv2d,wm as deregisterOp,lf as device_util,Ji as diag,jr as dilation2d,pf as disableDeprecationWarnings,zi as dispose,mf as disposeVariables,Ct as div,Br as divNoNan,Hr as dot,Wr as dropout,qr as einsum,Ur as elu,cf as enableDebugMode,df as enableProdMode,Gr as enclosingPowerOfTwo,hf as engine,Xi as ensureShape,V as env,Kr as equal,Jr as erf,Qr as euclideanNorm,Xr as exp,Wt as expandDims,Zr as expm1,Yr as eye,Mr as fft,en as fill,ff as findBackend,yf as findBackendFactory,tn as floor,an as floorDiv,gf as forceHalfFloat,Nu as fused,Dt as gather,hu as gatherND,bf as gather_util,Nf as getBackend,wf as getGradient,Tf as getKernel,Sf as getKernelsForBackend,vf as gpgpu_util,Of as grad,_f as grads,sn as greater,rn as greaterEqual,nn as ifft,on as imag,qt as image,yu as inTopKAsync,hm as initializers,Ef as input,Mt as io,un as irfft,ln as isFinite,pn as isInf,mn as isNaN,B as keep,cm as kernel_impls,Af as layers,cn as leakyRelu,dn as less,hn as lessEqual,fn as linalg,Zi as linspace,Tm as loadGraphModel,Sm as loadGraphModelSync,kf as loadLayersModel,yn as localResponseNormalization,gn as log,bn as log1p,Nn as logSigmoid,wn as logSoftmax,Tn as logSumExp,Sn as logicalAnd,vn as logicalNot,On as logicalOr,_n as logicalXor,En as losses,Mi as lowerBound,W as matMul,mm as math,An as max,kn as maxPool,In as maxPool3d,to as maxPoolWithArgmax,$n as maximum,Dn as mean,If as memory,ao as meshgrid,fm as metrics,Cn as min,zn as minimum,Ln as mirrorPad,Fn as mod,$f as model,ym as models,xn as moments,ou as movingAverage,ae as mul,ro as multiRNNCell,io as multinomial,Vn as neg,Df as nextFrame,Pn as norm,Rn as notEqual,Ce as oneHot,te as ones,jn as onesLike,T as op,uo as outerProduct,oe as pad,po as pad1d,co as pad2d,fo as pad3d,go as pad4d,Bn as pool,zt as pow,Hn as prelu,Wn as print,qn as prod,Cf as profile,No as raggedGather,To as raggedRange,vo as raggedTensorToTensor,_o as rand,xo as randomGamma,_t as randomNormal,Po as randomStandardNormal,Et as randomUniform,jo as randomUniformInt,Un as range,zf as ready,Gn as real,Kn as reciprocal,Lf as registerBackend,Ff as registerCallbackConstructor,xf as registerGradient,Vf as registerKernel,Nm as registerOp,gm as regularizers,Jn as relu,Qn as relu6,Pf as removeBackend,v as reshape,ue as reverse,Ho as reverse1d,qo as reverse2d,Go as reverse3d,Jo as reverse4d,Xn as rfft,Zn as round,Yn as rsqrt,H as scalar,lu as scatterND,Rf as scatter_util,Ze as searchSorted,Mn as selu,ei as separableConv2d,jf as sequential,Bf as serialization,Hf as setBackend,Wf as setPlatform,qf as setWebGLContext,Xo as setdiff1dAsync,Uf as shared,ye as sigmoid,ti as sign,ai as signal,si as sin,ri as sinh,U as slice,ni as slice1d,ii as slice2d,oi as slice3d,ui as slice4d,Gf as slice_util,li as softmax,pi as softplus,mi as spaceToBatchND,ci as sparse,cu as sparseToDense,di as spectral,hi as split,fi as sqrt,yi as square,gi as squaredDifference,$t as squeeze,ie as stack,bi as step,Ni as stridedSlice,wi as string,ge as sub,Ti as sum,Kf as sumOutType,Si as tan,De as tanh,G as tensor,Ut as tensor1d,ze as tensor2d,vi as tensor3d,Zo as tensor4d,Yo as tensor5d,Mo as tensor6d,tu as tensorScatterUpdate,Jf as tensor_util,pm as test_util,x as tidy,Oi as tile,Qf as time,_i as topk,Xf as train,Bt as transpose,Ei as truncatedNormal,Ai as unique,Zf as unregisterGradient,Yf as unregisterKernel,ki as unsortedSegmentSum,le as unstack,Mf as upcastType,au as upperBound,ey as util,ty as valueAndGrad,ay as valueAndGrads,Ii as variable,sy as variableGrads,Om as version,Gp as version_converter,zu as version_core,nm as version_cpu,Pi as version_layers,im as version_webgl,ry as webgl,ny as webgl_util,$i as where,Zt as whereAsync,Di as zeros,Ci as zerosLike};
